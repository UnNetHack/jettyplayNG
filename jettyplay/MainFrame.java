/*
 * MainFrame.java
 */

package jettyplay;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Font;
import java.awt.RenderingHints;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.ClipboardOwner;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.HierarchyBoundsListener;
import java.awt.event.HierarchyEvent;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URL;
import java.text.AttributedString;
import java.util.Arrays;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;
import javax.imageio.stream.MemoryCacheImageOutputStream;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.Timer;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileFilter;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JSlider;
import javax.swing.JSpinner;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

/**
 * The application's main frame.
 */
@SuppressWarnings("serial")
public class MainFrame extends JFrame
        implements ClipboardOwner, TemporalProgress {

    /**
     * Creates a new main window for the Jettyplay application.
     */
    public MainFrame() {
        replayTerminal = new SwingTerminal(); // must exist before initComponents
        initComponents();
        // some components the autogenerated code doesn't know about
        sidebarToolbarPanel.add(replayTerminal);
        sidebarPane = new SidebarPanel(new AttributedString[] {
            new AttributedString("This is a free GPL program, but comes with "+
                    "no warranty. See Help | Licence Information for details.")
        });
        sidebarToolbar.add(sidebarPane);
        syncAntialiasingWithMenu();

        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                setIconImage(new ImageIcon(MainFrame.class.getClassLoader().
                        getResource("jettyplay/resources/icon.png")).getImage());
            }
        });
        // set no file to be open
        currentSource = null;

        // initialize the streaming timer
        // all this one does is change the max time on a streaming recording
        // whose length is not known (i.e. still streaming)
        streamingTimer = new Timer(500, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                Ttyrec r = getCurrentTtyrec();
                try {
                    if (r != null && r.isStreaming()
                            && !currentSource.knownLength()) {
                        r.setLengthOffset((double) (new Date().getTime()
                                - r.getLastActivity().getTime()) / 1000.0);
                        synchSliderMaximum();
                        updateSidebar();
                    }
                } catch (NullPointerException ex) {
                    // do nothing; source must have vanished asynchronously
                    // while trying to run the command
                }
            }
        });
        streamingTimer.start();

        // initialize the playing timer
        // default play rate is 50fps; most of the time it's very quick to
        // update (nothing moves but the slider), so a high rate is fine
        playTimer = new Timer(50, new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                if (autoskipButton.isSelected() &&
                    previousFrameIndex != getCurrentTtyrec().getFrameCount() - 1 &&
                    (double)speedSpinner.getValue() > 0) {
                    double curTime = timeSlider.getValue() / timeScaling;
                    double nextFrameTime =
                            getCurrentTtyrec().getFrameAtIndex(previousFrameIndex + 1).
                            getRelativeTimestamp();
                    double thisFrameTime =
                            getCurrentFrame().
                            getRelativeTimestamp();
                    // We want to scale logarithmically; we reduce the length
                    // of the frame to its natural logarithm plus one, unless
                    // it's already at 1 or below.
                    if (nextFrameTime - thisFrameTime > 1 &&
                            (curTime - thisFrameTime) >
                            Math.log(nextFrameTime - thisFrameTime) + 1) {
                        // Skip to the next frame.
                        goForwardOneFrame(null);
                        return;
                    }
                }
                canUpdateTimeStartedAt = false; // prevent rounding error accumulation
                if (timeSlider.getValue() != timeSlider.getMaximum() ||
                        (double)speedSpinner.getValue() < 0) {
                    // Don't update the value if already at the end and going
                    // forwards; that can cause the frame to glitch back to a previous
                    // one if there's two frames at almost the same time at the end
                    // of the recording.
                    timeSlider.setValue((int)(sliderValueStartedAt +
                      (double) (new Date().getTime() - timeStartedAt) *
                      (double)speedSpinner.getValue() * timeScaling / 1000));
                }
                if ((double)speedSpinner.getValue() > 0) {
                    if (previousFrameIndex == getCurrentTtyrec().getFrameCount() - 1 &&
                            (!getCurrentTtyrec().isStreaming() ||
                             getCurrentSource().knownLength())) {
                        playing = false;
                        playButton.setSelected(false);
                        playPauseMenuItem.setSelected(false);
                        playTimer.stop();
                        updateSidebar();
                    } else if (timeSlider.getValue() == timeSlider.getMaximum())
                        goForwardOneFrame(null);
                } else {
                    // Not quite symmetrical with the case of going forwards;
                    // the last frame can be selected only at the very end of
                    // the recording, whereas the first frame lasts for positive
                    // rather than zero time. Also, we can stop playing after
                    // rewinding to the start even if streaming, because the
                    // start of the stream doesn't move further back in time.
                    if (previousFrameIndex == 0) {
                        if (timeSlider.getValue() == timeSlider.getMinimum()) {
                            playing = false;
                            playButton.setSelected(false);
                            playPauseMenuItem.setSelected(false);
                            playTimer.stop();
                            updateSidebar();
                        }
                    } else if (timeSlider.getValue() == timeSlider.getMinimum())
                        goBackOneFrame(null);
                }
            }
        });
    }

    /**
     * Shows the About... dialog box.
     */
    public void showAboutBox() {
        if (aboutBox == null) {
            JFrame mainFrame = this;
            aboutBox = new AboutDialog(mainFrame);
            aboutBox.setLocationRelativeTo(mainFrame);
        }
        aboutBox.setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     */
    @SuppressWarnings("unchecked")
    private void initComponents() {
        /* This was originally generated by NetBean's Form Editor, but it
         * lost track of the form upon an upgrade to a new version. So now
         * it's being edited by hand.
         */
        uiBuilder = new UIBuilder(false);
        
        mainPanel = uiBuilder.addJPanel(getContentPane(), null);
        timePanel = uiBuilder.addJPanel(mainPanel, BorderLayout.SOUTH);
        JPanel mainToolbarPanel = uiBuilder.addJPanel(mainPanel, BorderLayout.CENTER);

        timeSlider = uiBuilder.addJSlider(timePanel, BorderLayout.CENTER,
                "Seek to time", new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                timeSliderStateChanged(evt);
            }
        });
        timeSlider.setUI(new LoadingProgressSliderUI(timeSlider,this));
        timeSlider.setValue(0);
        timeSlider.setMaximum(1);

        curTime = uiBuilder.addJLabel(timePanel, BorderLayout.LINE_START,
                "0:00",SwingConstants.RIGHT);
        maxTime = uiBuilder.addJLabel(timePanel, BorderLayout.LINE_END,
                "0:00",SwingConstants.LEFT);

        mainToolbar = uiBuilder.addJToolBar(mainToolbarPanel, BorderLayout.NORTH);

        uiBuilder.addJButton(mainToolbar,"Go to the start of the recording",
                "first.png", new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goToStart(evt);
            }
        });
        uiBuilder.addJButton(mainToolbar,"Go backward one frame",
                "backframe.png",new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goBackOneFrame(evt);
            }
        });
        playButton = uiBuilder.addJToggleButton(mainToolbar,"Start or pause playback",
                "play.png", true,new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                playButtonChanged(evt);
            }
        });
        uiBuilder.addJButton(mainToolbar,"Go forward one frame",
                "forwardframe.png",new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goForwardOneFrame(evt);
            }
        });
        uiBuilder.addJButton(mainToolbar,"Go to the end of the recording",
                "last.png",new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goToEnd(evt);
            }
        });
        uiBuilder.addJSeparator(mainToolbar);

        /* We do this one by hand, because it's a little complex and because
           there's no code reuse benefit from uiBuilder. */
        speedSpinner = new JSpinner(new SpinnerNumberModel(Double.valueOf(1.0d),
                null, null, Double.valueOf(1.0d)));
        speedSpinner.setToolTipText("Speed at which to replay the ttyrec");
        speedSpinner.setEditor(new JSpinner.DefaultEditor(speedSpinner));
        speedSpinner.setFocusable(false);
        ((JSpinner.DefaultEditor)speedSpinner.getEditor())
                .getTextField().setFocusable(false);
        speedSpinner.setPreferredSize(
                new Dimension((int)(mainToolbar.getPreferredSize().getHeight()-4),
                              (int)speedSpinner.getMinimumSize().getHeight()));
        speedSpinner.setMaximumSize(speedSpinner.getPreferredSize());
        ((JSpinner.DefaultEditor)speedSpinner.getEditor()).getTextField()
                .addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                speedSpinnerMouseClicked(evt);
            }
        });
        speedSpinner.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent evt) {
                speedSpinnerMouseClicked(evt);
            }
        });
        speedSpinner.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                speedSpinnerStateChanged(evt);
            }
        });
        mainToolbar.add(speedSpinner);
        
        autoskipButton = uiBuilder.addJToggleButton(mainToolbar,
            "Automatically skip past long periods of inactivity",
            "autoskip.png", false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                autoskipButtonStateChanged(evt);
            }
        });

        sidebarToolbarPanel = uiBuilder.addJPanel(mainToolbarPanel,
                BorderLayout.CENTER);

        sidebarToolbar = uiBuilder.addJToolBar(sidebarToolbarPanel,
                BorderLayout.SOUTH);
        sidebarToolbar.setLayout(new BoxLayout(sidebarToolbar, BoxLayout.X_AXIS));

        /* Another by-hand addition. */
        sidebarTypeComboBox = new JComboBox<>();
        sidebarTypeComboBox.setModel(new DefaultComboBoxModel<>(
                new String[] { "Properties", "Annotations", "Playlist", "Raw Data" }));
        sidebarTypeComboBox.setFocusable(false);
        sidebarTypeComboBox.setMaximumSize(sidebarTypeComboBox.getPreferredSize());
        sidebarTypeComboBox.setName("sidebarTypeComboBox"); // NOI18N
        sidebarTypeComboBox.addItemListener(new ItemListener() {
            public void itemStateChanged(ItemEvent evt) {
                sidebarTypeComboBoxItemStateChanged(evt);
            }
        });
        sidebarTypeComboBox.addHierarchyBoundsListener(new HierarchyBoundsListener() {
            public void ancestorMoved(HierarchyEvent evt) {
            }
            public void ancestorResized(HierarchyEvent evt) {
                sidebarTypeComboBoxAncestorResized(evt);
            }
        });
        sidebarToolbar.add(sidebarTypeComboBox);

        menuBar = new JMenuBar();

        fileMenu = uiBuilder.addJMenu(menuBar, 'f', "File");
        uiBuilder.addJMenuItem(fileMenu, 'o', "Open...", "control O", false,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                openMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJMenuItem(fileMenu, 'u', "Open URL...", "control shift O",
                false,new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                openURLMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJSeparator(fileMenu);
        uiBuilder.addJMenuItem(fileMenu, 'v', "Save as Video...", null,
                true, new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                saveAsVideoMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJSeparator(fileMenu);
        uiBuilder.addJMenuItem(fileMenu, 'x', "Exit", "control X", false,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });

        JMenu editMenu = uiBuilder.addJMenu(menuBar, 'e', "Edit");
        uiBuilder.addJMenuItem(editMenu, 'f', "Find...", "control F", true,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                findMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJSeparator(editMenu);
        screenshotMenu = uiBuilder.addJMenu(editMenu, 'c',
                "Copy Screenshot");
        uiBuilder.addJMenuItem(screenshotMenu, 'p', "As Plain Text",
                null, true, new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                plainTextScreenshotMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJMenuItem(screenshotMenu, 'h', "As HTML",
                null, true, new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                htmlScreenshotMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJMenuItem(screenshotMenu, 'i', "As Image",
                null, true, new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                imageScreenshotMenuItemActionPerformed(evt);
            }
        });

        viewMenu = uiBuilder.addJMenu(menuBar, 'v', "View");
        fullScreenMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'f',
                "Full Screen", "F11", false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                fullScreenMenuItemStateChanged(evt);
            }
        });
        fullScreenMenuItem.setEnabled(
                GraphicsEnvironment.getLocalGraphicsEnvironment()
                .getDefaultScreenDevice().isFullScreenSupported());
        sidebarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'i',
                "Information Bar", null, false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                sidebarMenuItemStateChanged(evt);
            }
        });
        sidebarMenuItem.setSelected(true);
        toolBarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 't',
                "Toolbar", null, false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                toolBarMenuItemStateChanged(evt);
            }
        });
        toolBarMenuItem.setSelected(true);
        menuBarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'm',
                "Menu Bar", "control M", false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                menuBarMenuItemStateChanged(evt);
            }
        });
        menuBarMenuItem.setSelected(true);
        controlBarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'c',
                "Control Bar", null, false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                controlBarMenuItemStateChanged(evt);
            }
        });
        controlBarMenuItem.setSelected(true);
        uiBuilder.addJSeparator(viewMenu);
        ButtonGroup terminalSizeGroup = new ButtonGroup();
        JMenu terminalSizeMenu = uiBuilder.addJMenu(viewMenu, 'z', "Terminal Size");
        autodetectTerminalSizeMenuItem = uiBuilder.addJRadioButtonMenuItem(
                terminalSizeMenu, 'a', "Autodetect", null, true, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                autodetectTerminalSizeMenuItemActionPerformed(evt);
            }
        });
        terminalSizeGroup.add(autodetectTerminalSizeMenuItem);
        autodetectTerminalSizeMenuItem.setSelected(true);
        fixedTerminalSizeMenuItem = uiBuilder.addJRadioButtonMenuItem(
                terminalSizeMenu, 'f', "Fixed Size...", null, true,
                new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {}
        });
        fixedTerminalSizeMenuItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                fixedTerminalSizeMenuItemActionPerformed(evt);
            }
        });
        encodingMenu = uiBuilder.addJMenu(viewMenu, 'e', "Encoding");
        ButtonGroup encodingButtonGroup = new ButtonGroup();
        autodetectEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
                encodingMenu, 'a', "Autodetect", null, true, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                autodetectEncodingMenuItemStateChanged(evt);
            }
        });
        encodingButtonGroup.add(autodetectEncodingMenuItem);
        autodetectEncodingMenuItem.setSelected(true);
        unicodeEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
                encodingMenu, 'u', "Unicode (UTF-8)", null, true, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                unicodeEncodingMenuItemStateChanged(evt);
            }
        });
        encodingButtonGroup.add(unicodeEncodingMenuItem);
        ibmEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
                encodingMenu, 'i', "IBM (IBM850)", null, true, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                ibmEncodingMenuItemStateChanged(evt);
            }
        });
        encodingButtonGroup.add(autodetectEncodingMenuItem);
        latin1EncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
                encodingMenu, 'l', "Latin-1 (ISO-8859-1)", null, true, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                latin1EncodingMenuItemStateChanged(evt);
            }
        });
        encodingButtonGroup.add(latin1EncodingMenuItem);
        JMenu antialiasingMenu = uiBuilder.addJMenu(viewMenu, 'a', "Antialiasing");
        ButtonGroup antialiasButtonGroup = new ButtonGroup();
        antialiasingOffMenuItem = uiBuilder.addJRadioButtonMenuItem(
                antialiasingMenu, 'o', "Off", null, false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                antialiasingOffMenuItemStateChanged(evt);
            }
        });
        antialiasButtonGroup.add(antialiasingOffMenuItem);
        antialiasingDefaultMenuItem = uiBuilder.addJRadioButtonMenuItem(
                antialiasingMenu, 'd', "Default", null, false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                antialiasingDefaultMenuItemStateChanged(evt);
            }
        });
        antialiasButtonGroup.add(antialiasingDefaultMenuItem);
        antialiasingDefaultMenuItem.setSelected(true);
        antialiasingRGBMenuItem = uiBuilder.addJRadioButtonMenuItem(
                antialiasingMenu, 'r', "Subpixel (RGB)", null, false,
                new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                antialiasingRGBMenuItemStateChanged(evt);
            }
        });
        antialiasButtonGroup.add(antialiasingRGBMenuItem);
        antialiasingBGRMenuItem = uiBuilder.addJRadioButtonMenuItem(
                antialiasingMenu, 'b', "Subpixel (BGR)", null, false,
                new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                antialiasingBGRMenuItemStateChanged(evt);
            }
        });
        antialiasButtonGroup.add(antialiasingBGRMenuItem);
        uiBuilder.addJMenuItem(viewMenu, 's', "Set Font...", null, false,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                setFontMenuItemActionPerformed(evt);
            }
        });

        JMenu goMenu = uiBuilder.addJMenu(menuBar, 'g', "Go");
        playPauseMenuItem = uiBuilder.addJCheckBoxMenuItem(goMenu, 'p',
                "Play", "SPACE", true, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                updatePlayPaused(evt);
            }
        });
        uiBuilder.addJSeparator(goMenu);
        uiBuilder.addJMenuItem(goMenu, 't', "To Start", "HOME", true,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goToStart(evt);
            }
        });
        uiBuilder.addJMenuItem(goMenu, 'e', "To End", "END", true,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goToEnd(evt);
            }
        });
        uiBuilder.addJMenuItem(goMenu, 'n', "Back One Frame", "LEFT", true,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goBackOneFrame(evt);
            }
        });
        uiBuilder.addJMenuItem(goMenu, 'f', "Forward One Frame", "RIGHT", true,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goForwardOneFrame(evt);
            }
        });
        uiBuilder.addJMenuItem(goMenu, 'a', "To Frame...", "G", true,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goToSpecificFrameMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJSeparator(goMenu);
        uiBuilder.addJMenuItem(goMenu, 'q', "Quicker", "UP", false,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goQuickerMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJMenuItem(goMenu, 's', "Slower", "DOWN", false,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goSlowerMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJMenuItem(goMenu, 'n', "Normal Speed", "1", false,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goTimesOneMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJMenuItem(goMenu, 'i', "Specific Speed", "X", false,
                new ActionListener () {
            public void actionPerformed(ActionEvent evt) {
                speedSpinnerMouseClicked(null);
            }
        });

        uiBuilder.addJMenuItem(goMenu, 'r', "Reverse Direction", "R", false,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                goRewindMenuItemActionPerformed(evt);
            }
        });
        autoskipMenuItem =uiBuilder.addJCheckBoxMenuItem(goMenu,
                'k', "Skip Inactivity", "L", false, new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                autoskipMenuItemStateChanged(evt);
            }
        });
        JMenu helpMenu = uiBuilder.addJMenu(menuBar, 'h', "Help");
        uiBuilder.addJMenuItem(helpMenu, 'a', "About...", null, false,
                new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                aboutMenuItemActionPerformed(evt);
            }
        });
        uiBuilder.addJMenuItem(helpMenu, 'l', "License information...", null,
                false, new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                licenceMenuItemActionPerformed(evt);
            }
        });

        setJMenuBar(menuBar);
        uiBuilder.massSetEnabled(false);
    }

    /**
     * A function that runs when the Open menu item is selected, that opens
     * a ttyrec file.
     * @param evt Information on which event was performed
     */
    private void openMenuItemActionPerformed(ActionEvent evt) {
        InputStreamable iStream = null;
        try {
            File f = null;
            JFileChooser fileChooser = new JFileChooser(lastDirectory);
            fileChooser.setAcceptAllFileFilterUsed(false);
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".rec") ||
                           f.getName().toLowerCase().endsWith(".ttyrec") ||
                           f.getName().toLowerCase().endsWith(".ttyrec2") ||
                           f.getName().toLowerCase().endsWith(".rec.gz") ||
                           f.getName().toLowerCase().endsWith(".ttyrec.gz") ||
                           f.getName().toLowerCase().endsWith(".ttyrec2.gz") ||
                           f.getName().toLowerCase().endsWith(".rec.bz2") ||
                           f.getName().toLowerCase().endsWith(".ttyrec.bz2") ||
                           f.getName().toLowerCase().endsWith(".ttyrec2.bz2") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "All supported file extensions";
                }
            });
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".rec") ||
                           f.getName().toLowerCase().endsWith(".ttyrec") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "Ttyrec files (*.rec, *.ttyrec)";
                }
            });
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".ttyrec2") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "Annotated ttyrec files (*.ttyrec2)";
                }
            });
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".ttyrec.gz") ||
                           f.getName().toLowerCase().endsWith(".ttyrec.bz2") ||
                           f.getName().toLowerCase().endsWith(".rec.gz") ||
                           f.getName().toLowerCase().endsWith(".rec.bz2") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "Compressed ttyrec files (*.{ttyrec,rec}.{gz,bz2})";
                }
            });
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".ttyrec2.gz") ||
                           f.getName().toLowerCase().endsWith(".ttyrec2.bz2") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "Compressed annotated ttyrec files (*.ttyrec2.{gz,bz2})";
                }
            });
            fileChooser.addChoosableFileFilter(fileChooser.getAcceptAllFileFilter());
            
            if (fileChooser.showOpenDialog(mainPanel) != JFileChooser.APPROVE_OPTION) {
                return;
            }
            f = fileChooser.getSelectedFile();
            iStream = new InputStreamableFileWrapper(f);
            lastDirectory = f.getParentFile();
        } catch (java.security.AccessControlException ex) {
            try {
                // Try using a JNLP service to open a file. This is done using
                // reflection so it works even without a JNLP library present.

                // FileOpenService fos = (FileOpenService) ServiceManager.lookup("javax.jnlp.FileOpenService");
                Object fos = getClass().getClassLoader().loadClass("javax.jnlp.ServiceManager").
                             getMethod("lookup", String.class).invoke(null, "javax.jnlp.FileOpenService");
                // FileContents fc = fos.openFileDialog("", new String[]{"rec","ttyrec"});
                Object fc = getClass().getClassLoader().loadClass("javax.jnlp.FileOpenService").
                             getMethod("openFileDialog", String.class, String[].class).
                             invoke(fos, "", new String[]{
                    "rec","ttyrec","ttyrec2","rec.gz","ttyrec.gz","rec.bz2","ttyrec.bz2"});
                if (fc == null) return;
                iStream = new InputStreamableFileContentsWrapper(fc);
                if (iStream == null) throw new IOException();
            } catch (ClassNotFoundException | NoSuchMethodException |
                     SecurityException | IllegalAccessException |
                     IllegalArgumentException | InvocationTargetException | IOException ex1) {
                return;
            }
        }
        if (iStream == null) return;
        openSourceFromInputStreamable(iStream);
    }

    private void timeSliderStateChanged(ChangeEvent evt) {
        if (getCurrentTtyrec() == null) return;
        setTimeLabels();
        int i = getCurrentTtyrec().getFrameIndexAtRelativeTime(
                (double) timeSlider.getValue() / timeScaling);
        if (canUpdateSelectedFrame)
            goToSpecificFrame(i, false);
        else
            canUpdateSelectedFrame = true;
        if (!canUpdateTimeStartedAt) {
            canUpdateTimeStartedAt = true;
            return;
        }
        timeStartedAt = new Date().getTime();
        sliderValueStartedAt = timeSlider.getValue();
    }

    private void updatePlayPaused(ChangeEvent evt) {
        if (getCurrentTtyrec() == null) return;
        playing = playPauseMenuItem.isSelected();
        if (playing) {
            timeStartedAt = new Date().getTime();
            sliderValueStartedAt = timeSlider.getValue();
            if ((Double)speedSpinner.getValue() == 0)
                speedSpinner.setValue(1.0);
            playTimer.restart();
        } else
            playTimer.stop();
        if (playPauseMenuItem.isSelected() != playButton.isSelected())
            playButton.setSelected(playPauseMenuItem.isSelected());
        updateSidebar();
    }

    private void playButtonChanged(ChangeEvent evt) {
        if (playPauseMenuItem.isSelected() != playButton.isSelected())
            playPauseMenuItem.setSelected(playButton.isSelected());
    }

    private void goToStart(ActionEvent evt) {
        goToSpecificFrame(0, true);
    }

    private void goToEnd(ActionEvent evt) {
        // The time of the last frame might not equal the end of the recording
        // if we're streaming. And the end of the recording might not equal the
        // time of the last frame if the recording ends with two frames less
        // than a millisecond apart. So the solution is to set both separately.
        timeSlider.setValue(timeSlider.getMaximum());
        goToSpecificFrame(getCurrentTtyrec().getFrameCount()-1, false);
    }

    private void goBackOneFrame(ActionEvent evt) {
        goToSpecificFrame(previousFrameIndex-1, true);
    }

    private void goForwardOneFrame(ActionEvent evt) {
        goToSpecificFrame(previousFrameIndex+1, true);
    }

    private void licenceMenuItemActionPerformed(ActionEvent evt) {
        new LicenceDialog(this).setVisible(true);
    }

    private void autoskipButtonStateChanged(ChangeEvent evt) {
        autoskipMenuItem.setSelected(autoskipButton.isSelected());
        updateSidebar();
    }

    private void autoskipMenuItemStateChanged(ChangeEvent evt) {
        autoskipButton.setSelected(autoskipMenuItem.isSelected());
        updateSidebar();
    }

    private void unicodeEncodingMenuItemStateChanged(ChangeEvent evt) {
        if (unicodeEncodingMenuItem.isSelected())
            setTtyrecFormat(Ttyrec.Encoding.UTF8);
    }

    private void ibmEncodingMenuItemStateChanged(ChangeEvent evt) {
        if (ibmEncodingMenuItem.isSelected())
            setTtyrecFormat(Ttyrec.Encoding.IBM);
    }

    private void latin1EncodingMenuItemStateChanged(ChangeEvent evt) {
        if (latin1EncodingMenuItem.isSelected())
            setTtyrecFormat(Ttyrec.Encoding.Latin1);
    }

    private void fullScreenMenuItemStateChanged(ChangeEvent evt) {
        GraphicsEnvironment.getLocalGraphicsEnvironment().
                getDefaultScreenDevice().setFullScreenWindow(
                fullScreenMenuItem.isSelected() ?
                    this : null);
    }

    private void sidebarMenuItemStateChanged(ChangeEvent evt) {
        sidebarToolbar.setVisible(sidebarMenuItem.isSelected());
    }

    private void toolBarMenuItemStateChanged(ChangeEvent evt) {
        mainToolbar.setVisible(toolBarMenuItem.isSelected());
    }

    private void menuBarMenuItemStateChanged(ChangeEvent evt) {
        if (menuBarMenuItem.isSelected()) {
            if (!menuBarShowing) {
                //menuBar.setPreferredSize(new Dimension(32767,savedMenuBarHeight));
                menuBar.setPreferredSize(null);
                menuBar.setVisible(false);
                menuBar.setVisible(true);
                menuBarShowing = true;
            }
        } else {
            if (menuBarShowing) {
                menuBar.setPreferredSize(new Dimension(32767,1));
                menuBar.setVisible(false);
                menuBar.setVisible(true);
                menuBarShowing = false;
            }
        }
    }

    private void controlBarMenuItemStateChanged(ChangeEvent evt) {
        timePanel.setVisible(controlBarMenuItem.isSelected());
    }

    private void antialiasingOffMenuItemStateChanged(ChangeEvent evt) {
        if(antialiasingOffMenuItem.isSelected())
            replayTerminal.setTextAntialiasingType(RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    }

    private void antialiasingDefaultMenuItemStateChanged(ChangeEvent evt) {
        if(antialiasingDefaultMenuItem.isSelected())
            replayTerminal.setTextAntialiasingType(RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    }

    private void antialiasingRGBMenuItemStateChanged(ChangeEvent evt) {
        if(antialiasingRGBMenuItem.isSelected())
            replayTerminal.setTextAntialiasingType(safelyGetRenderingHint("VALUE_TEXT_ANTIALIAS_LCD_HRGB"));
    }

    private void antialiasingBGRMenuItemStateChanged(ChangeEvent evt) {
        if(antialiasingBGRMenuItem.isSelected())
            replayTerminal.setTextAntialiasingType(safelyGetRenderingHint("VALUE_TEXT_ANTIALIAS_LCD_HBGR"));
    }

    private void goRewindMenuItemActionPerformed(ActionEvent evt) {
        speedSpinner.setValue((Double)speedSpinner.getValue() * -1.0);
    }

    private void goTimesOneMenuItemActionPerformed(ActionEvent evt) {
        speedSpinner.setValue(1.0);
    }

    private void goSlowerMenuItemActionPerformed(ActionEvent evt) {
        if (!((Double)speedSpinner.getValue()).equals(1.0))
            speedSpinner.setValue((Double)speedSpinner.getValue() - 1.0);
        else
            speedSpinner.setValue(-1.0);
    }

    private void goQuickerMenuItemActionPerformed(ActionEvent evt) {
        if (!((Double)speedSpinner.getValue()).equals(-1.0))
            speedSpinner.setValue((Double)speedSpinner.getValue() + 1.0);
        else
            speedSpinner.setValue(1.0);
    }

    private void goToSpecificFrameMenuItemActionPerformed(ActionEvent evt) {
        String frameString = JOptionPane.showInputDialog(
                encodingMenu, "Go to which frame?", ""+(previousFrameIndex+1));
        if (frameString == null) return;
        try {
            goToSpecificFrame(Integer.valueOf(frameString) - 1, true);
        } catch (NumberFormatException ex) {
            // ignore invalid input
        }
    }

    private void findMenuItemActionPerformed(ActionEvent evt) {
        if (findBox == null)
            findBox = new FindDialog(this,this);
        findBox.setVisible(true);
        findBox.fixDefaultFocus();
        findBox.requestFocusInWindow();
    }

    private void plainTextScreenshotMenuItemActionPerformed(ActionEvent evt) {
        VDUBuffer vdub = null;
        if (getCurrentTtyrec() != null) vdub = getCurrentFrame().getTerminalState();
        if (vdub == null) vdub = new vt320();
        StringBuilder sb = new StringBuilder();
        for (char[] s: vdub.charArray) {
            sb.append(s);
            sb.append('\n');
        }
        setClipboardContents(new StringSelection(sb.toString()));
    }

    private void htmlScreenshotMenuItemActionPerformed(ActionEvent evt) {
        final String s = replayTerminal.asHTML();
        setClipboardContents(new DataHandler(new DataSource() {
            public InputStream getInputStream() throws IOException {
                return new ByteArrayInputStream(s.getBytes());
            }
            public OutputStream getOutputStream() throws IOException {
                throw new IOException("Cannot write to a screenshot");
            }
            public String getContentType() {
                return "text/html";
            }
            public String getName() {
                return "Jettyplay Screenshot";
            }
        }));
    }

    private void imageScreenshotMenuItemActionPerformed(ActionEvent evt) {
        // Prepare a stream for writing the image data to
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            String mime;
            try (ImageOutputStream ios = new MemoryCacheImageOutputStream(baos)) {
                String[] mimes = ImageIO.getWriterMIMETypes();
                if (mimes.length == 0) {
                    JOptionPane.showMessageDialog(screenshotMenu,
                            "No image encoders found", "Jettyplay",
                            JOptionPane.ERROR_MESSAGE);
                    return;
                }
                mime = mimes[0];
                Arrays.sort(mimes);
                if (Arrays.binarySearch(mimes, "image/png") > 0) // #NOI18N
                    mime = "image/png";
                ImageWriter iw = ImageIO.getImageWritersByMIMEType(mime).next();
                iw.setOutput(ios);
                if (antialiasingBGRMenuItem.isSelected() ||
                    antialiasingRGBMenuItem.isSelected())
                    replayTerminal.setTextAntialiasingType(RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
                BufferedImage bi = new BufferedImage(
                        replayTerminal.getCurrentTerminalWidth(),
                        replayTerminal.getCurrentTerminalHeight(),
                        BufferedImage.TYPE_INT_RGB);
                replayTerminal.redraw(bi.createGraphics(),
                        bi.getWidth(), bi.getHeight());
                iw.write(bi);
                antialiasingBGRMenuItemStateChanged(null);
                antialiasingRGBMenuItemStateChanged(null);
            }
            final String mime_final = mime;
            final byte[] byteStream = baos.toByteArray();
            DataSource ds = new DataSource() {
                public InputStream getInputStream() throws IOException {
                    return new ByteArrayInputStream(byteStream);
                }
                public OutputStream getOutputStream() throws IOException {
                    throw new IOException("Cannot write to a screenshot");
                }
                public String getContentType() {
                    return mime_final;
                }
                public String getName() {
                    return "Jettyplay Screenshot";
                }
            };
            setClipboardContents(new DataHandler(ds));
        } catch (IOException ex) {
            return;
        }
    }

    private void speedSpinnerStateChanged(ChangeEvent evt) {
        if ((((Double)speedSpinner.getValue()).equals(0.0)) && playing) {
            playPauseMenuItem.setSelected(false);
            playButton.setSelected(false);
            playing = false;
            playTimer.stop();
        }
        sliderValueStartedAt = timeSlider.getValue();
        timeStartedAt = new Date().getTime();
        updateSidebar();
    }

    private void sidebarTypeComboBoxAncestorResized(HierarchyEvent evt) {
        int oldOrientation = sidebarToolbar.getOrientation();
        sidebarToolbar.setLayout(new BoxLayout(sidebarToolbar,
                oldOrientation == SwingConstants.HORIZONTAL ?
                    BoxLayout.X_AXIS : BoxLayout.Y_AXIS));
        // fix layout
        sidebarToolbar.invalidate();
        sidebarToolbar.validate();
        // fix sizing (by forcing a size recalculation)
        sidebarToolbar.setOrientation(SwingConstants.HORIZONTAL);
        sidebarToolbar.setOrientation(SwingConstants.VERTICAL);
        sidebarToolbar.setOrientation(oldOrientation);
        sidebarPane.setVertical(oldOrientation == SwingConstants.VERTICAL);
    }

    private void sidebarTypeComboBoxItemStateChanged(ItemEvent evt) {
        updateSidebar();
    }

    private void speedSpinnerMouseClicked(MouseEvent evt) {
        String frameString = JOptionPane.showInputDialog(
                encodingMenu, "Set speed to what?", ""+(speedSpinner.getValue()));
        if (frameString == null) return;
        try {
            speedSpinner.setValue(Double.valueOf(frameString));
        } catch (NumberFormatException ex) {
            // ignore invalid input
        }
    }

    private void aboutMenuItemActionPerformed(ActionEvent evt) {
        new AboutDialog(this).setVisible(true);
    }

    private void exitMenuItemActionPerformed(ActionEvent evt) {
        System.exit(0);
    }

    private void autodetectEncodingMenuItemStateChanged(ChangeEvent evt) {
        if (autodetectEncodingMenuItem.isSelected() && getCurrentTtyrec() != null)
            getCurrentTtyrec().resetEncoding();
    }

    private void openURLMenuItemActionPerformed(ActionEvent evt) {
        try {
            URL u = new URL(JOptionPane.showInputDialog(
                    fileMenu, "Open which URL?"));
            openSourceFromInputStreamable(new InputStreamableURLWrapper(u));
        } catch (MalformedURLException ex) {
            System.out.println(ex.getMessage());
            return;
        } catch (NullPointerException ex) {
            return;
        }
    }

    private void saveAsVideoMenuItemActionPerformed(ActionEvent evt) {
        /* We don't check to see if analyze process is maxed out, because in
         * the case of streaming ttyrecs, there's no way to tell.
         */
        if (currentSource.getTtyrec() != null &&
            currentSource.getTtyrec().getFrameCount() > 0 &&
            currentSource.backportDecodeProgress()
                >= currentSource.getTtyrec().getFrameCount())
            new SaveAsVideoDialog(this, currentSource.getTtyrec()).setVisible(true);
        else
            JOptionPane.showMessageDialog(fileMenu,
                    "Please wait for the ttyrec to finish loading first.",
                    "Cannot Save as Video", JOptionPane.ERROR_MESSAGE);
    }
    
    private void setFontMenuItemActionPerformed(ActionEvent evt) {
        FontDialog fontBox = new FontDialog(this,this);
        fontBox.setVisible(true);
        fontBox.fixDefaultFocus();
        fontBox.requestFocusInWindow();
    }

    private void autodetectTerminalSizeMenuItemActionPerformed(ChangeEvent evt) {
        if (autodetectTerminalSizeMenuItem.isSelected() && getCurrentTtyrec() != null) {
            getCurrentTtyrec().setForcedSize(-1,-1);
            autodetectTerminalSizeMenuItem.setSelected(true);
            fixedTerminalSizeMenuItem.setSelected(false);
            getCurrentSource().repeatCurrentDecodeWorker();
        }
    }

    private void fixedTerminalSizeMenuItemActionPerformed(ActionEvent evt) {
        if (fixedTerminalSizeMenuItem.isSelected()) {
            String s = JOptionPane.showInputDialog(viewMenu,
                    "Fix terminal window at what size (WxH)?", "80x24");
            if (s == null) return;
            setForcedSizeFromString(s);
        }
    }

    private void setForcedSizeFromString(String s) {
        Matcher m = Pattern.compile("\\s*(\\d+)\\s*x\\s*(\\d+)\\s*").
                matcher(s);
        if (!m.matches()) return;
        getCurrentTtyrec().setForcedSize(
                Integer.valueOf(m.group(1)), Integer.valueOf(m.group(2)));
        autodetectTerminalSizeMenuItem.setSelected(false);
        fixedTerminalSizeMenuItem.setSelected(true);
        getCurrentSource().repeatCurrentDecodeWorker();
    }

    private void setClipboardContents(Transferable t) {
        try {
            this.getToolkit().
                    getSystemClipboard().setContents(t, this);
        } catch (java.security.AccessControlException ex) {
            try {
                // Try using a JNLP service to access the clipboard.

                // ClipboardService cs = (ClipboardService) ServiceManager.lookup("javax.jnlp.ClipboardService");
                Object cs = getClass().getClassLoader().loadClass("javax.jnlp.ServiceManager").
                            getMethod("lookup", String.class).invoke(null, "javax.jnlp.ClipboardService");
                // cs.setContents(t);
                getClass().getClassLoader().loadClass("javax.jnlp.ClipboardService").
                            getMethod("setContents", Transferable.class).invoke(cs, t);
            } catch (ClassNotFoundException | NoSuchMethodException |
                     SecurityException | IllegalAccessException |
                     IllegalArgumentException | InvocationTargetException ex1) {
                return;
            }
        }
    }

    private void syncAntialiasingWithMenu() {
        antialiasingOffMenuItemStateChanged(null);
        antialiasingDefaultMenuItemStateChanged(null);
        antialiasingRGBMenuItemStateChanged(null);
        antialiasingBGRMenuItemStateChanged(null);
    }

    private void setTtyrecFormat(Ttyrec.Encoding format) {
        if (getCurrentTtyrec() == null) return;
        if (getCurrentTtyrec().getEncoding() == format) return;
        getCurrentTtyrec().setEncoding(format);
        getCurrentSource().repeatCurrentDecodeWorker();
    }

    private void goToSpecificFrame(int frame, boolean changeTimeSlider) {
        if (getCurrentTtyrec() == null) return;
        if (frame < 0 || frame >= getCurrentTtyrec().getFrameCount()) return;
        TtyrecFrame f = getCurrentTtyrec().getFrameAtIndex(frame);
        if (changeTimeSlider) {
            timeSlider.setValue((int)Math.ceil(
                    f.getRelativeTimestamp() * timeScaling));
            timeSliderStateChanged(null);
        }
        if (frame != previousFrameIndex) {
            replayTerminal.setVDUBuffer(f.getTerminalState());
            f.setDirty(false);
        }
        previousFrameIndex = frame;
        updateSidebar();
    }

    private String timeToString(double time) {
        int t = (int)time;
        if (t<0) t = 0;
        String s = (t/60) + ":";
        if (t > 3600) {
            s = (t/3600) + ":";
            if ((t/60)%60 < 10) s += "0";
            s += (t/60)%60 + ":";
        }
        if (t%60 < 10) s += "0";
        s += t%60;
        return s;
    }

    private void setTimeLabels() {
        if (getCurrentTtyrec() == null) return;
        maxTime.setText(timeToString(getCurrentTtyrec().getLength()));
        curTime.setPreferredSize(maxTime.getPreferredSize());
        curTime.setText(timeToString((double)timeSlider.getValue() / timeScaling));
    }

    private boolean oldEnabled = false;
    private void massSetEnabled(boolean enabled) {
        if (enabled == oldEnabled) return;
        oldEnabled = enabled;
        if (!enabled) {
            unicodeEncodingMenuItem.setEnabled(enabled);
            ibmEncodingMenuItem.setEnabled(enabled);
            latin1EncodingMenuItem.setEnabled(enabled);
        }
        uiBuilder.massSetEnabled(enabled);
    }

    private void unloadFile() {
        playing = false;
        playTimer.stop();
        playPauseMenuItem.setSelected(false);
        playButton.setSelected(false);
        massSetEnabled(false);
        if (getCurrentSource() != null) getCurrentSource().completeCancel();
        currentSource = null;
        replayTerminal.setVDUBuffer(new vt320());
        maxTime.setText("0:00");
        curTime.setPreferredSize(maxTime.getPreferredSize());
        curTime.setText("0:00");
        timeSlider.setValue(0);
        timeSlider.setMaximum(1);
        timeSlider.repaint();
        VDUBuffer.resetCaches();
        updateSidebar();
    }

    private void openSourceFromInputStreamable(InputStreamable iStream) {
        unloadFile();
        currentSource = new InputStreamTtyrecSource(iStream);
        getCurrentSource().completeUnpause();
        getCurrentSource().addDecodeListener(new ProgressListener() {
            public void progressMade() {
                decodeProgressMade();
            }
        });
        getCurrentSource().addAnalysisListener(new ProgressListener() {
            public void progressMade() {
                analysisProgressMade();
            }
        });
        getCurrentSource().addReadListener(new ProgressListener() {
            public void progressMade() {
                readProgressMade();
            }
        });
        getCurrentSource().start();
        setTimeLabels();
        massSetEnabled(true);
        previousFrameIndex = 0;
        // If viewing an inherently streaming source, set up for streaming;
        // jump to the end and set play mode on.
        if (iStream.mustBeStreamable()) {
            timeSlider.setValue(timeSlider.getMaximum());
            goToSpecificFrame(getCurrentTtyrec().getFrameCount() - 1, false);
            playPauseMenuItem.setSelected(true);
            playButton.setSelected(true);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private JRadioButtonMenuItem antialiasingBGRMenuItem;
    private JRadioButtonMenuItem antialiasingDefaultMenuItem;
    private JRadioButtonMenuItem antialiasingOffMenuItem;
    private JRadioButtonMenuItem antialiasingRGBMenuItem;
    private JRadioButtonMenuItem autodetectEncodingMenuItem;
    private JRadioButtonMenuItem autodetectTerminalSizeMenuItem;
    private JToggleButton autoskipButton;
    private JCheckBoxMenuItem autoskipMenuItem;
    private JCheckBoxMenuItem controlBarMenuItem;
    private JLabel curTime;
    private JMenu encodingMenu;
    private JMenu fileMenu;
    private JRadioButtonMenuItem fixedTerminalSizeMenuItem;
    private JCheckBoxMenuItem fullScreenMenuItem;
    private JRadioButtonMenuItem ibmEncodingMenuItem;
    private JRadioButtonMenuItem latin1EncodingMenuItem;
    private JPanel mainPanel;
    private JToolBar mainToolbar;
    private JLabel maxTime;
    private JMenuBar menuBar;
    private JCheckBoxMenuItem menuBarMenuItem;
    private JToggleButton playButton;
    private JCheckBoxMenuItem playPauseMenuItem;
    private JMenu screenshotMenu;
    private JCheckBoxMenuItem sidebarMenuItem;
    private JToolBar sidebarToolbar;
    private JPanel sidebarToolbarPanel;
    private JComboBox<String> sidebarTypeComboBox;
    private JSpinner speedSpinner;
    private JPanel timePanel;
    private JSlider timeSlider;
    private JCheckBoxMenuItem toolBarMenuItem;
    private JRadioButtonMenuItem unicodeEncodingMenuItem;
    private JMenu viewMenu;
    private UIBuilder uiBuilder;
    // End of variables declaration
    private SwingTerminal replayTerminal;
    private SidebarPanel sidebarPane;
    private boolean menuBarShowing = true;

    private TtyrecSource currentSource;

    // TODO: Reduce this in the case of excessively time-long ttyrecs,
    // to avoid an integer overflow
    private int timeScaling = 1000;
    private boolean playing = false;
    private final Timer playTimer;
    private final Timer streamingTimer;
    private int previousFrameIndex = -1;
    private long timeStartedAt;
    private int sliderValueStartedAt;
    private boolean canUpdateTimeStartedAt = true;
    private boolean canUpdateSelectedFrame = true;

    private JDialog aboutBox;
    private FindDialog findBox;

    private File lastDirectory = null;
    
    public double getMaximumTime() {
        if (getCurrentTtyrec() == null) return 0.0;
        return getCurrentTtyrec().getLength();
    }
    public double getCurrentTime() {
        if (getCurrentTtyrec() == null) return 0.0;
        if (getCurrentSource().backportDecodeProgress() ==
                getCurrentTtyrec().getFrameCount())
            return getCurrentTtyrec().getLength();
        if (getCurrentSource().backportDecodeProgress() == 0) return 0.0;
        return getCurrentTtyrec().getFrameAtIndex(getCurrentSource().backportDecodeProgress()-1).getRelativeTimestamp();
    }
    public double getFuzzyTime() {
        if (getCurrentTtyrec() == null) return 0.0;
        if (getCurrentSource().decodeProgress() == getCurrentTtyrec().getFrameCount())
            return getCurrentTtyrec().getLength();
        if (getCurrentSource().decodeProgress() == 0) return 0.0;
        return getCurrentTtyrec().getFrameAtIndex(getCurrentSource().decodeProgress()-1).getRelativeTimestamp();
    }

    private void synchSliderMaximum() {
        if (getCurrentTtyrec() == null) return;
        boolean atmax = timeSlider.getValue() == timeSlider.getMaximum();
        canUpdateTimeStartedAt = false;
        canUpdateSelectedFrame = false;
        timeSlider.setMaximum((int) (getCurrentTtyrec().getLength() * timeScaling));
        if (atmax && playing) {
            canUpdateTimeStartedAt = true;
            // to avoid glitches, let the play loop handle updating the
            // selected frame
            canUpdateSelectedFrame = false;
            timeSlider.setValue(timeSlider.getMaximum());
        }
        timeSlider.repaint();        
        updateSidebar();
        setTimeLabels();
    }

    /**
     * A listener that should be called whenever progress has been made in
     * reading an input source for a currently opened ttyrec.
     */
    public void readProgressMade() {
        synchSliderMaximum();
    }

    /**
     * A listener that should be called whenever progress has been made in
     * decoding a currently opened ttyrec.
     */
    public void decodeProgressMade() {
        timeSlider.repaint();
        updateSidebar();
        if (getCurrentTtyrec() != null &&
            getCurrentTtyrec().getFrameCount() > previousFrameIndex &&
            getCurrentFrame().isDirty()) {
            replayTerminal.setVDUBuffer(
                    getCurrentFrame().getTerminalState());
            getCurrentFrame().setDirty(false);
        }
    }

    /**
     * A listener that should be called whenever progress has been made in
     * analysing a currently open ttyrec.
     */
    public void analysisProgressMade() {
        synchSliderMaximum();
        setTimeLabels();
        updateSidebar();
        // Synch the selected encoding from the ttyrec...
        if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.Autodetect)
            autodetectEncodingMenuItem.setSelected(true);
        if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.IBM)
            ibmEncodingMenuItem.setSelected(true);
        if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.Latin1)
            latin1EncodingMenuItem.setSelected(true);
        if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.UTF8)
            unicodeEncodingMenuItem.setSelected(true);
        // /before/ setting which item is enabled, or we'll end up copying
        // the old value over the new one rather than vice versa.
        ibmEncodingMenuItem.setEnabled
            (getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.IBM));
        unicodeEncodingMenuItem.setEnabled
            (getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.UTF8));
        latin1EncodingMenuItem.setEnabled
            (getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.Latin1));
        // if we just decoded the wanted frame, jump to it
        if (getCurrentTtyrec().getWantedFrame() > -1 &&
                getCurrentTtyrec().getFrameCount() >
                getCurrentTtyrec().getWantedFrame()) {
            goToSpecificFrame(getCurrentTtyrec().getWantedFrame(), true);
            getCurrentTtyrec().setWantedFrame(-1);
        }
    }

    private TtyrecFrame getCurrentFrame() {
        try {
            return getCurrentTtyrec().getFrameAtIndex(previousFrameIndex);
        } catch(IndexOutOfBoundsException ex) {
            return null;
        }
    }

    private void setSidebarPropertyMessage() {
        if (getCurrentTtyrec() != null) {
            AttributedString[] as = new AttributedString[7];
            as[0] = new AttributedString(playing ? "Playing" : "Paused");
            as[0].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD);
            double time = (double)timeSlider.getValue() / timeScaling;
            as[1] = new AttributedString("Frame: " + (previousFrameIndex+1) +
                        " / " + getCurrentTtyrec().getFrameCount());
            as[1].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
            as[2] = new AttributedString("Time: " + timeToString(time) +
                        " / " + timeToString(getCurrentTtyrec().getLength()));
            as[2].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,4);
            as[3] = new AttributedString("Speed: x" + speedSpinner.getValue() +
                        (autoskipButton.isSelected() ? " log" : ""));
            as[3].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
            try {
                as[4] = new AttributedString("Size: " +
                        getCurrentFrame().getTerminalState().getColumns() +
                        " x " + getCurrentFrame().getTerminalState().getRows());
            } catch (Exception e) {
                as[4] = new AttributedString("Size: ? x ?");
            }
            as[4].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
            as[5] = new AttributedString("Memory used: " +
                    ((Runtime.getRuntime().totalMemory()) - Runtime.getRuntime().freeMemory()) +
                        " / " + Runtime.getRuntime().maxMemory());
            as[5].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,11);
            try {
                as[6] = new AttributedString("URI: " + getCurrentSource().getURI().toString());
            } catch (URISyntaxException ex) {
                as[6] = new AttributedString("URI: unknown");
            }
            as[6].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,3);
            setSidebarPaneContents(as);
        } else {
            setSidebarPaneContents(new AttributedString[]
                        {new AttributedString("No file loaded.")});
        }
    }

    /**
     * Searches for a given string in the currently open ttyrec; if it's found,
     * then seeks the current ttyrec to the frame where it was found.
     * @param searchFor The string to search for.
     * @param searchForward Whether to search forwards (true) or backwards (false).
     * @param regex Whether the string to search for is actually a regex.
     * @param ignoreCase Whether to do a case-insensitive (true) or case-sensitive (false) search.
     * @param wrapAround Whether to restart the search at one end of the ttyrec if it's finished at the other end.
     * @return A string that can be displayed to the user, summarising the results of the search.
     */
    public String searchInTtyrec(String searchFor, boolean searchForward,
            boolean regex, boolean ignoreCase, boolean wrapAround) {
        Pattern p;
        try {
            // Regex.LITERAL would be nice, but it's too new. So we quote the
            // regex by hand, according to Perl 5 quoting rules; all letters
            // and all digits are left as-is, other characters are preceded by
            // a backslash.
            if (!regex) {
                StringBuilder sb = new StringBuilder();
                for (char c: searchFor.toCharArray()) {
                    if (!Character.isLetter(c) && !Character.isDigit(c))
                        sb.append('\\');
                    sb.append(c);
                }
                searchFor = sb.toString();
            }
            p = Pattern.compile(searchFor, (ignoreCase ? Pattern.CASE_INSENSITIVE : 0));
        } catch (PatternSyntaxException e) {
            return "Invalid regular expression.";
        }
        for (int i = previousFrameIndex;
                i < getCurrentTtyrec().getFrameCount() && i >= 0; i += searchForward ? 1 : -1) {
            if (i == previousFrameIndex) {
                continue;
            }
            if (getCurrentTtyrec().getFrameAtIndex(i).containsPattern(p)) {
                goToSpecificFrame(i, true);
                return "Found at frame " + i + ".";
            }
        }
        if (wrapAround) {
            for (int i = searchForward ? 0 : getCurrentTtyrec().getFrameCount() - 1;
                    i != previousFrameIndex;
                    i += searchForward ? 1 : -1) {
                if (getCurrentTtyrec().getFrameAtIndex(i).containsPattern(p)) {
                    goToSpecificFrame(i, true);
                    return "Found at frame " + i + " (wrapped).";
                }
            }
        }
        return "Match not found.";
    }

    /**
     * A listener called when the window loses clipboard ownership.
     * @param clipboard The clipboard whose ownership was lost.
     * @param contents The contents of the lost clipboard.
     */
    public void lostOwnership(Clipboard clipboard, Transferable contents) {
        // We don't care.
    }

    private void setSidebarPaneContents(AttributedString[] string) {
        sidebarPane.setStartToEnd(true);
        sidebarPane.setContents(Arrays.asList(string));
    }

    static int sidebarUpdates = 0;
    private void updateSidebar() {
        if (sidebarPane == null) return; /* we're in the constructor */
        // Java is rather bad at garbage-collecting the text used for the
        // sidebar labels, for some reason. So every 100000 sidebar updates,
        // we run GC by hand.
        sidebarUpdates++;
        if (sidebarUpdates >= 100000) {
            sidebarUpdates = 0;
            //System.gc();
        }
        // TODO: Fix magic numbers.
        // 0 = properties; 1 = annotations; 2 = playlist; 3 = raw data
        if (sidebarTypeComboBox.getSelectedIndex() == 0)
            setSidebarPropertyMessage();
        if (sidebarTypeComboBox.getSelectedIndex() == 1) {
            if (getCurrentTtyrec() == null || getCurrentFrame() == null) {
                sidebarPane.setStartToEnd(true);
                setSidebarPaneContents(new AttributedString[]
                {new AttributedString("No file loaded.")});
            } else if (getCurrentTtyrec().getFileType() == Ttyrec.FileType.Ttyrec) {
                sidebarPane.setStartToEnd(true);
                setSidebarPaneContents(new AttributedString[]
                    {new AttributedString("No annotations available.")});
            } else {
                sidebarPane.setStartToEnd(false);
                sidebarPane.setContents(getCurrentFrame().
                        getRawDataIterator((double)timeSlider.getValue()
                                              / timeScaling, 1));
            }
        }
        if (sidebarTypeComboBox.getSelectedIndex() == 3) {
            if (getCurrentTtyrec() == null || getCurrentFrame() == null) {
                sidebarPane.setStartToEnd(true);
                setSidebarPaneContents(new AttributedString[]
                    {new AttributedString("No file loaded.")});
            } else {
                sidebarPane.setStartToEnd(false);
                sidebarPane.setContents(getCurrentFrame().
                        getRawDataIterator((double)timeSlider.getValue()
                                              / timeScaling, 0));
            }
        }
    }

    /**
     * Gets the currently visible ttyrec source; that's the selected source from
     * the playlist.
     * @return the currently selected ttyrec source.
     */
    private TtyrecSource getCurrentSource() {
        return currentSource;
    }


    /**
     * Returns the currently viewed ttyrec.
     * Even if more than one ttyrec is open, only the one currently showing is
     * returned.
     * @return The current ttyrec, or null if there are no open ttyrecs.
     */
    public Ttyrec getCurrentTtyrec() {
        if (getCurrentSource() == null) return null;
        return getCurrentSource().getTtyrec();
    }

    // This method exists to avoid causing problems with missing fields
    // in early JDK versions.
    private Object safelyGetRenderingHint(String hintName) {
        try {
            return RenderingHints.class.getField(hintName).get(null);
        } catch(NoSuchFieldException | SecurityException |
                IllegalArgumentException | IllegalAccessException e) {
            return RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
        }
    }

    void setTerminalFont(String fontName) {
        replayTerminal.setFont(new Font(
                fontName,Font.PLAIN,11));
    }

    /**
     * Returns the font currently used by the terminal.
     * @return A Font that is used to display data in the terminal.
     */
    public Font getTerminalFont() {
        return replayTerminal.getFont();
    }

    /**
     * The main entry point for the Jettyplay application.
     * Parses and applies the effects of command-line arguments; if the
     * arguments did not request an immediate exit, also creates a new main
     * window for the Jettyplay application GUI and shows it.
     * @param args The command-line arguments to parse.
     */
    public static void main(String[] args) {
        // Look for help or version args, and reply and exit if one is given.
        boolean ddflag = false;
        for(String a : args) {
            if (ddflag) {ddflag = false; continue;}
            if(a.equals("-v") || a.equals("--version")) {
                System.err.println("This is jettyplay version "+
                        AboutDialog.versionInfo+".");
                System.err.println(AboutDialog.copyrightInfo);
                System.exit(0);
            }
            if(a.equals("-h") || a.equals("--help")) {
                System.err.println("filenames   Load the given file/files");
                System.err.println("-z 80x24    Force terminal size to 80x24 (likewise for other sizes)");
                System.err.println("-f 1200     Jump to frame 1200 upon loading (likewise for other frames)");
                System.err.println("-s 4        Set speed to 4x realtime (likewise for other speeds)");
                System.err.println("-l          Automatically fast-forward through periods of inactivity");
                System.err.println("--          Treat next arg as a filename even if it starts with -");
                System.err.println("-h          Show this help, then exit");
                System.err.println("-v          Show version and copyright information, then exit");
                System.exit(0);
            }
            if(a.equals("--")) ddflag = true;
        }
        // Set up the GUI.
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException |
                 IllegalAccessException | UnsupportedLookAndFeelException ex) {
            // if we can't set a system look and feel, just use the default...
        }
        // Set up networking, if we're allowed to.
        try {
            URL.setURLStreamHandlerFactory(new StreamingURLStreamHandlerFactory());
        } catch (SecurityException e) {
            // oh well, we just can't use those protocols because the security
            // manager won't let us
            System.err.println(
                    "Nonstandard protocols disabled for security reasons.\n");
        }
        MainFrame me = new MainFrame();
        me.setDefaultCloseOperation(EXIT_ON_CLOSE);
        me.setSize(800, 600);
        me.setTitle("Jettyplay");
        me.setVisible(true);
        // Apply the effects of options
        ddflag = false;
        boolean speedflag = false;
        boolean sizeflag = false;
        boolean frameflag = false;
        String pendingSize = null;
        String pendingFrame = null;
        for (String a : args) {
            if (speedflag) {
                try {
                    me.speedSpinner.setValue(Double.valueOf(a));
                } catch (NumberFormatException ex) {
                    // ignore invalid input
                }
                speedflag = false;
                continue;
            }
            // if size or frame is being set this arg, turn on ddflag so the
            // arg isn't interpreted as anything else, and fall past the
            // filename check to the size/frame check
            if (sizeflag) {pendingSize = a; ddflag = true;}
            if (frameflag) {pendingFrame = a; ddflag = true;}
            if (a.equals("-l") && !ddflag) {
                me.autoskipButton.setSelected(true);
                me.autoskipMenuItem.setSelected(true);
                me.updateSidebar();
                continue;
            }
            if(a.equals("-s") && !ddflag) {speedflag = true; continue;}
            if(a.equals("-f") && !ddflag) {frameflag = true; continue;}
            if(a.equals("-z") && !ddflag) {sizeflag = true; continue;}
            if(a.equals("--") && !ddflag) {ddflag = true; continue;}            
            ddflag = false;
            if (!sizeflag && !frameflag) {
                // Looks like it's a filename...
                try {
                    URL u = new URL(a);
                    me.openSourceFromInputStreamable(new InputStreamableURLWrapper(u));
                } catch (MalformedURLException ex) {
                    File f = new File(a);
                    me.openSourceFromInputStreamable(new InputStreamableFileWrapper(f));
                }
            }
            // Check to see whether to apply forced size, or to go to a frame.
            sizeflag = false;
            frameflag = false;
            if (me.getCurrentSource() != null && pendingSize != null) {
                me.setForcedSizeFromString(pendingSize);
                pendingSize = null;
            }
            if (me.getCurrentSource() != null && pendingFrame != null) {
                try {
                    me.getCurrentSource().setWantedFrame(
                            Integer.valueOf(pendingFrame) - 1);
                    pendingFrame = null;
                } catch (NumberFormatException nfe) {
                    // do nothing
                }
            }
        }
    }
}
