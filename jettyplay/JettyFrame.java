/*
 * JettyFrame.java
 */

package jettyplay;

import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Font;
import java.awt.RenderingHints;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.ClipboardOwner;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.font.TextAttribute;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URL;
import java.text.AttributedString;
import java.util.Arrays;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;
import javax.imageio.stream.MemoryCacheImageOutputStream;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.Timer;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileFilter;
import javax.swing.JOptionPane;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;

/**
 * The application's main frame.
 */
@SuppressWarnings("serial")
public class JettyFrame extends JFrame
        implements ClipboardOwner, TemporalProgress {

    /**
     * Creates a new main window for the Jettyplay application.
     */
    public JettyFrame() {
        initComponents();
        // some components the autogenerated code doesn't know about
        replayTerminal = new SwingTerminal();
        sidebarToolbarPanel.add(replayTerminal);
        sidebarPane = new JettySidebar(new AttributedString[] {
            new AttributedString("This is a free GPL program, but comes with "+
                    "no warranty. See Help | Licence Information for details.")
        });
        sidebarToolbar.add(sidebarPane);
        syncAntialiasingWithMenu();

        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                setIconImage(new ImageIcon(JettyFrame.class.getClassLoader().
                        getResource("jettyplay/resources/icon.png")).getImage());
            }
        });
        // set no file to be open
        currentSource = null;

        // initialize the streaming timer
        // all this one does is change the max time on a streaming recording
        // whose length is not known (i.e. still streaming)
        streamingTimer = new Timer(500, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                Ttyrec r = getCurrentTtyrec();
                try {
                    if (r != null && r.isStreaming()
                            && !currentSource.knownLength()) {
                        r.setLengthOffset((double) (new Date().getTime()
                                - r.getLastActivity().getTime()) / 1000.0);
                        synchSliderMaximum();
                        updateSidebar();
                    }
                } catch (NullPointerException ex) {
                    // do nothing; source must have vanished asynchronously
                    // while trying to run the command
                }
            }
        });
        streamingTimer.start();

        // initialize the playing timer
        // default play rate is 50fps; most of the time it's very quick to
        // update (nothing moves but the slider), so a high rate is fine
        playTimer = new Timer(50, new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                if (autoskipButton.isSelected() &&
                    previousFrameIndex != getCurrentTtyrec().getFrameCount() - 1 &&
                    ((Double)(speedSpinner.getValue())) > 0) {
                    double curTime = (double) timeSlider.getValue() / timeScaling;
                    double nextFrameTime =
                            getCurrentTtyrec().getFrameAtIndex(previousFrameIndex + 1).
                            getRelativeTimestamp();
                    double thisFrameTime =
                            getCurrentFrame().
                            getRelativeTimestamp();
                    // We want to scale logarithmically; we reduce the length
                    // of the frame to its natural logarithm plus one, unless
                    // it's already at 1 or below.
                    if (nextFrameTime - thisFrameTime > 1 &&
                            (curTime - thisFrameTime) >
                            Math.log(nextFrameTime - thisFrameTime) + 1) {
                        // Skip to the next frame.
                        goForwardOneFrame(null);
                        return;
                    }
                }
                canUpdateTimeStartedAt = false; // prevent rounding error accumulation
                if (timeSlider.getValue() != timeSlider.getMaximum() ||
                        (Double)speedSpinner.getValue() < 0) {
                    // Don't update the value if already at the end and going
                    // forwards; that can cause the frame to glitch back to a previous
                    // one if there's two frames at almost the same time at the end
                    // of the recording.
                    timeSlider.setValue((int) (sliderValueStartedAt +
                            (double) (new Date().getTime() - timeStartedAt) *
                            (Double)speedSpinner.getValue() * timeScaling / 1000));
                }
                if ((Double)speedSpinner.getValue() > 0) {
                    if (previousFrameIndex == getCurrentTtyrec().getFrameCount() - 1 &&
                            (!getCurrentTtyrec().isStreaming() ||
                             getCurrentSource().knownLength())) {
                        playing = false;
                        playButton.setSelected(false);
                        playPauseMenuItem.setSelected(false);
                        playTimer.stop();
                        updateSidebar();
                    } else if (timeSlider.getValue() == timeSlider.getMaximum())
                        goForwardOneFrame(null);
                } else {
                    // Not quite symmetrical with the case of going forwards;
                    // the last frame can be selected only at the very end of
                    // the recording, whereas the first frame lasts for positive
                    // rather than zero time. Also, we can stop playing after
                    // rewinding to the start even if streaming, because the
                    // start of the stream doesn't move further back in time.
                    if (previousFrameIndex == 0) {
                        if (timeSlider.getValue() == timeSlider.getMinimum()) {
                            playing = false;
                            playButton.setSelected(false);
                            playPauseMenuItem.setSelected(false);
                            playTimer.stop();
                            updateSidebar();
                        }
                    } else if (timeSlider.getValue() == timeSlider.getMinimum())
                        goBackOneFrame(null);
                }
            }
        });
    }

    /**
     * Shows the About... dialog box.
     */
    public void showAboutBox() {
        if (aboutBox == null) {
            JFrame mainFrame = this;
            aboutBox = new JettyAboutBox(mainFrame);
            aboutBox.setLocationRelativeTo(mainFrame);
        }
        aboutBox.setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        encodingButtonGroup = new javax.swing.ButtonGroup();
        antialiasButtonGroup = new javax.swing.ButtonGroup();
        mainPanel = new javax.swing.JPanel();
        timePanel = new javax.swing.JPanel();
        timeSlider = new javax.swing.JSlider();
        curTime = new javax.swing.JLabel();
        maxTime = new javax.swing.JLabel();
        mainToolbarPanel = new javax.swing.JPanel();
        mainToolbar = new javax.swing.JToolBar();
        startButton = new javax.swing.JButton();
        backwardFrameButton = new javax.swing.JButton();
        playButton = new javax.swing.JToggleButton();
        forwardFrameButton = new javax.swing.JButton();
        endButton = new javax.swing.JButton();
        jSeparator2 = new javax.swing.JToolBar.Separator();
        speedSpinner = new javax.swing.JSpinner();
        autoskipButton = new javax.swing.JToggleButton();
        sidebarToolbarPanel = new javax.swing.JPanel();
        sidebarToolbar = new javax.swing.JToolBar();
        sidebarTypeComboBox = new javax.swing.JComboBox();
        menuBar = new javax.swing.JMenuBar();
        openMenuItem = new javax.swing.JMenuItem();
        openURLMenuItem = new javax.swing.JMenuItem();
        exitMenuItem = new javax.swing.JMenuItem();
        editMenu = new javax.swing.JMenu();
        findMenuItem = new javax.swing.JMenuItem();
        jSeparator5 = new javax.swing.JSeparator();
        screenshotMenu = new javax.swing.JMenu();
        plainTextScreenshotMenuItem = new javax.swing.JMenuItem();
        htmlScreenshotMenuItem = new javax.swing.JMenuItem();
        imageScreenshotMenuItem = new javax.swing.JMenuItem();
        viewMenu = new javax.swing.JMenu();
        fullScreenMenuItem = new javax.swing.JCheckBoxMenuItem();
        sidebarMenuItem = new javax.swing.JCheckBoxMenuItem();
        toolBarMenuItem = new javax.swing.JCheckBoxMenuItem();
        menuBarMenuItem = new javax.swing.JCheckBoxMenuItem();
        controlBarMenuItem = new javax.swing.JCheckBoxMenuItem();
        jSeparator4 = new javax.swing.JSeparator();
        terminalSizeMenuItem = new javax.swing.JMenu();
        autodetectTerminalSizeMenuItem = new javax.swing.JRadioButtonMenuItem();
        fixedTerminalSizeMenuItem = new javax.swing.JRadioButtonMenuItem();
        encodingMenu = new javax.swing.JMenu();
        autodetectEncodingMenuItem = new javax.swing.JRadioButtonMenuItem();
        unicodeEncodingMenuItem = new javax.swing.JRadioButtonMenuItem();
        ibmEncodingMenuItem = new javax.swing.JRadioButtonMenuItem();
        latin1EncodingMenuItem = new javax.swing.JRadioButtonMenuItem();
        antialiasingMenu = new javax.swing.JMenu();
        antialiasingOffMenuItem = new javax.swing.JRadioButtonMenuItem();
        antialiasingDefaultMenuItem = new javax.swing.JRadioButtonMenuItem();
        antialiasingRGBMenuItem = new javax.swing.JRadioButtonMenuItem();
        antialiasingBGRMenuItem = new javax.swing.JRadioButtonMenuItem();
        setFontMenuItem = new javax.swing.JMenuItem();
        goMenu = new javax.swing.JMenu();
        playPauseMenuItem = new javax.swing.JCheckBoxMenuItem();
        jSeparator1 = new javax.swing.JSeparator();
        startMenuItem = new javax.swing.JMenuItem();
        endMenuItem = new javax.swing.JMenuItem();
        backwardFrameMenuItem = new javax.swing.JMenuItem();
        forwardFrameMenuItem = new javax.swing.JMenuItem();
        goToSpecificFrameMenuItem = new javax.swing.JMenuItem();
        jSeparator3 = new javax.swing.JSeparator();
        goQuickerMenuItem = new javax.swing.JMenuItem();
        goSlowerMenuItem = new javax.swing.JMenuItem();
        goTimesOneMenuItem = new javax.swing.JMenuItem();
        goRewindMenuItem = new javax.swing.JMenuItem();
        autoskipMenuItem = new javax.swing.JCheckBoxMenuItem();
        javax.swing.JMenu helpMenu = new javax.swing.JMenu();
        aboutMenuItem = new javax.swing.JMenuItem();
        licenceMenuItem = new javax.swing.JMenuItem();

        mainPanel.setFocusable(false);
        mainPanel.setName("mainPanel"); // NOI18N
        mainPanel.setLayout(new java.awt.BorderLayout());

        timePanel.setName("timePanel"); // NOI18N
        timePanel.setLayout(new java.awt.BorderLayout());

        timeSlider.setFont(timeSlider.getFont());
        timeSlider.setMaximum(1);
        timeSlider.setToolTipText("Seek to time");
        timeSlider.setValue(0);
        timeSlider.setEnabled(false);
        timeSlider.setFocusable(false);
        timeSlider.setName("timeSlider"); // NOI18N
        timeSlider.setUI(new JettySliderUI(timeSlider,this));
        timeSlider.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                timeSliderStateChanged(evt);
            }
        });
        timePanel.add(timeSlider, java.awt.BorderLayout.CENTER);

        curTime.setFont(curTime.getFont());
        curTime.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        curTime.setText("0:00"); // NOI18N
        curTime.setEnabled(false);
        curTime.setName("curTime"); // NOI18N
        timePanel.add(curTime, java.awt.BorderLayout.LINE_START);

        maxTime.setFont(maxTime.getFont());
        maxTime.setText("0:00"); // NOI18N
        maxTime.setEnabled(false);
        maxTime.setName("maxTime"); // NOI18N
        timePanel.add(maxTime, java.awt.BorderLayout.LINE_END);

        mainPanel.add(timePanel, java.awt.BorderLayout.SOUTH);

        mainToolbarPanel.setName("mainToolbarPanel"); // NOI18N
        mainToolbarPanel.setOpaque(false);
        mainToolbarPanel.setLayout(new java.awt.BorderLayout());

        mainToolbar.setRollover(true);
        mainToolbar.setFocusable(false);
        mainToolbar.setName("Control"); // NOI18N

        startButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/jettyplay/resources/first.png"))); // NOI18N
        startButton.setToolTipText("Go to the start of the recording");
        startButton.setEnabled(false);
        startButton.setFocusable(false);
        startButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        startButton.setName("startButton"); // NOI18N
        startButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goToStart(evt);
            }
        });
        mainToolbar.add(startButton);

        backwardFrameButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/jettyplay/resources/backframe.png"))); // NOI18N
        backwardFrameButton.setToolTipText("Go backward one frame");
        backwardFrameButton.setEnabled(false);
        backwardFrameButton.setFocusable(false);
        backwardFrameButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        backwardFrameButton.setName("backwardFrameButton"); // NOI18N
        backwardFrameButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        backwardFrameButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goBackOneFrame(evt);
            }
        });
        mainToolbar.add(backwardFrameButton);

        playButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/jettyplay/resources/play.png"))); // NOI18N
        playButton.setToolTipText("Start or pause playback");
        playButton.setEnabled(false);
        playButton.setFocusable(false);
        playButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        playButton.setName("playButton"); // NOI18N
        playButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        playButton.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                playButtonChanged(evt);
            }
        });
        mainToolbar.add(playButton);

        forwardFrameButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/jettyplay/resources/forwardframe.png"))); // NOI18N
        forwardFrameButton.setToolTipText("Go forward one frame");
        forwardFrameButton.setEnabled(false);
        forwardFrameButton.setFocusable(false);
        forwardFrameButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        forwardFrameButton.setName("forwardFrameButton"); // NOI18N
        forwardFrameButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        forwardFrameButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goForwardOneFrame(evt);
            }
        });
        mainToolbar.add(forwardFrameButton);

        endButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/jettyplay/resources/last.png"))); // NOI18N
        endButton.setToolTipText("Go to the end of the recording");
        endButton.setEnabled(false);
        endButton.setFocusable(false);
        endButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        endButton.setName("endButton"); // NOI18N
        endButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        endButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goToEnd(evt);
            }
        });
        mainToolbar.add(endButton);

        jSeparator2.setName("jSeparator2"); // NOI18N
        mainToolbar.add(jSeparator2);

        speedSpinner.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(1.0d), null, null, Double.valueOf(1.0d)));
        speedSpinner.setToolTipText("Speed at which to replay the ttyrec");
        speedSpinner.setEditor(new javax.swing.JSpinner.NumberEditor(speedSpinner, ""));
        ((javax.swing.JSpinner.NumberEditor)speedSpinner.getEditor()).getTextField().setFocusable(false);
        speedSpinner.setFocusable(false);
        speedSpinner.setName("speedSpinner"); // NOI18N
        speedSpinner.setPreferredSize(new Dimension((int)(mainToolbar.getPreferredSize().getHeight()-4),(int)speedSpinner.getMinimumSize().getHeight()));
        speedSpinner.setMaximumSize(speedSpinner.getPreferredSize());
        speedSpinner.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                speedSpinnerMouseClicked(evt);
            }
        });
        speedSpinner.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                speedSpinnerStateChanged(evt);
            }
        });
        ((javax.swing.JSpinner.NumberEditor)speedSpinner.getEditor()).getTextField().addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                speedSpinnerMouseClicked(evt);
            }
        });
        mainToolbar.add(speedSpinner);

        autoskipButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/jettyplay/resources/autoskip.png"))); // NOI18N
        autoskipButton.setToolTipText("Automatically skip past long periods of inactivity");
        autoskipButton.setFocusable(false);
        autoskipButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        autoskipButton.setName("autoskipButton"); // NOI18N
        autoskipButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        autoskipButton.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                autoskipButtonStateChanged(evt);
            }
        });
        mainToolbar.add(autoskipButton);

        mainToolbarPanel.add(mainToolbar, java.awt.BorderLayout.NORTH);

        sidebarToolbarPanel.setName("sidebarToolbarPanel"); // NOI18N
        sidebarToolbarPanel.setLayout(new java.awt.BorderLayout());

        sidebarToolbar.setRollover(true);
        sidebarToolbar.setName("Sidebar"); // NOI18N
        sidebarToolbar.setLayout(new javax.swing.BoxLayout(sidebarToolbar, javax.swing.BoxLayout.X_AXIS));

        sidebarTypeComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Properties", "Annotations", "Playlist", "Raw Data" }));
        sidebarTypeComboBox.setFocusable(false);
        sidebarTypeComboBox.setMaximumSize(sidebarTypeComboBox.getPreferredSize());
        sidebarTypeComboBox.setName("sidebarTypeComboBox"); // NOI18N
        sidebarTypeComboBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                sidebarTypeComboBoxItemStateChanged(evt);
            }
        });
        sidebarTypeComboBox.addHierarchyBoundsListener(new java.awt.event.HierarchyBoundsListener() {
            public void ancestorMoved(java.awt.event.HierarchyEvent evt) {
            }
            public void ancestorResized(java.awt.event.HierarchyEvent evt) {
                sidebarTypeComboBoxAncestorResized(evt);
            }
        });
        sidebarToolbar.add(sidebarTypeComboBox);

        sidebarToolbarPanel.add(sidebarToolbar, java.awt.BorderLayout.SOUTH);

        mainToolbarPanel.add(sidebarToolbarPanel, java.awt.BorderLayout.CENTER);

        mainPanel.add(mainToolbarPanel, java.awt.BorderLayout.CENTER);

        getContentPane().add(mainPanel, java.awt.BorderLayout.CENTER);

        menuBar.setName("menuBar"); // NOI18N

        fileMenu.setMnemonic('f');
        fileMenu.setText("File");
        fileMenu.setName("fileMenu"); // NOI18N

        openMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        openMenuItem.setMnemonic('o');
        openMenuItem.setText("Open...");
        openMenuItem.setName("openMenuItem"); // NOI18N
        openMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(openMenuItem);

        openURLMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        openURLMenuItem.setMnemonic('u');
        openURLMenuItem.setText("Open URL...");
        openURLMenuItem.setName("openURLMenuItem"); // NOI18N
        openURLMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openURLMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(openURLMenuItem);

        exitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        exitMenuItem.setMnemonic('x');
        exitMenuItem.setText("Exit");
        exitMenuItem.setName("exitMenuItem"); // NOI18N
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        menuBar.add(fileMenu);

        editMenu.setMnemonic('e');
        editMenu.setText("Edit");
        editMenu.setName("editMenu"); // NOI18N

        findMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F, java.awt.event.InputEvent.CTRL_MASK));
        findMenuItem.setMnemonic('f');
        findMenuItem.setText("Find...");
        findMenuItem.setEnabled(false);
        findMenuItem.setName("findMenuItem"); // NOI18N
        findMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findMenuItemActionPerformed(evt);
            }
        });
        editMenu.add(findMenuItem);

        jSeparator5.setName("jSeparator5"); // NOI18N
        editMenu.add(jSeparator5);

        screenshotMenu.setMnemonic('c');
        screenshotMenu.setText("Copy Screenshot");
        screenshotMenu.setName("screenshotMenu"); // NOI18N

        plainTextScreenshotMenuItem.setMnemonic('p');
        plainTextScreenshotMenuItem.setText("As Plain Text");
        plainTextScreenshotMenuItem.setName("plainTextScreenshotMenuItem"); // NOI18N
        plainTextScreenshotMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                plainTextScreenshotMenuItemActionPerformed(evt);
            }
        });
        screenshotMenu.add(plainTextScreenshotMenuItem);

        htmlScreenshotMenuItem.setMnemonic('h');
        htmlScreenshotMenuItem.setText("As HTML");
        htmlScreenshotMenuItem.setName("htmlScreenshotMenuItem"); // NOI18N
        htmlScreenshotMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                htmlScreenshotMenuItemActionPerformed(evt);
            }
        });
        screenshotMenu.add(htmlScreenshotMenuItem);

        imageScreenshotMenuItem.setMnemonic('i');
        imageScreenshotMenuItem.setText("As Image");
        imageScreenshotMenuItem.setName("imageScreenshotMenuItem"); // NOI18N
        imageScreenshotMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                imageScreenshotMenuItemActionPerformed(evt);
            }
        });
        screenshotMenu.add(imageScreenshotMenuItem);

        editMenu.add(screenshotMenu);

        menuBar.add(editMenu);

        viewMenu.setMnemonic('v');
        viewMenu.setText("View");
        viewMenu.setName("viewMenu"); // NOI18N

        fullScreenMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F11, 0));
        fullScreenMenuItem.setMnemonic('f');
        fullScreenMenuItem.setText("Full Screen");
        fullScreenMenuItem.setEnabled(GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().isFullScreenSupported());
        fullScreenMenuItem.setName("fullScreenMenuItem"); // NOI18N
        fullScreenMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                fullScreenMenuItemStateChanged(evt);
            }
        });
        viewMenu.add(fullScreenMenuItem);

        sidebarMenuItem.setMnemonic('i');
        sidebarMenuItem.setSelected(true);
        sidebarMenuItem.setText("Information Bar");
        sidebarMenuItem.setName("sidebarMenuItem"); // NOI18N
        sidebarMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                sidebarMenuItemStateChanged(evt);
            }
        });
        viewMenu.add(sidebarMenuItem);

        toolBarMenuItem.setMnemonic('t');
        toolBarMenuItem.setSelected(true);
        toolBarMenuItem.setText("Toolbar");
        toolBarMenuItem.setName("toolBarMenuItem"); // NOI18N
        toolBarMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                toolBarMenuItemStateChanged(evt);
            }
        });
        viewMenu.add(toolBarMenuItem);

        menuBarMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_M, java.awt.event.InputEvent.CTRL_MASK));
        menuBarMenuItem.setMnemonic('m');
        menuBarMenuItem.setSelected(true);
        menuBarMenuItem.setText("Menu Bar");
        menuBarMenuItem.setName("menuBarMenuItem"); // NOI18N
        menuBarMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                menuBarMenuItemStateChanged(evt);
            }
        });
        viewMenu.add(menuBarMenuItem);

        controlBarMenuItem.setMnemonic('c');
        controlBarMenuItem.setSelected(true);
        controlBarMenuItem.setText("Control Bar");
        controlBarMenuItem.setName("controlBarMenuItem"); // NOI18N
        controlBarMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                controlBarMenuItemStateChanged(evt);
            }
        });
        viewMenu.add(controlBarMenuItem);

        jSeparator4.setName("jSeparator4"); // NOI18N
        viewMenu.add(jSeparator4);

        terminalSizeMenuItem.setMnemonic('z');
        terminalSizeMenuItem.setText("Terminal Size");
        terminalSizeMenuItem.setName("terminalSizeMenuItem"); // NOI18N

        autodetectTerminalSizeMenuItem.setMnemonic('a');
        autodetectTerminalSizeMenuItem.setSelected(true);
        autodetectTerminalSizeMenuItem.setText("Autodetect");
        autodetectTerminalSizeMenuItem.setEnabled(false);
        autodetectTerminalSizeMenuItem.setName("autodetectTerminalSizeMenuItem"); // NOI18N
        autodetectTerminalSizeMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                autodetectTerminalSizeMenuItemActionPerformed(evt);
            }
        });
        terminalSizeMenuItem.add(autodetectTerminalSizeMenuItem);

        fixedTerminalSizeMenuItem.setMnemonic('f');
        fixedTerminalSizeMenuItem.setText("Fixed Size...");
        fixedTerminalSizeMenuItem.setEnabled(false);
        fixedTerminalSizeMenuItem.setName("fixedTerminalSizeMenuItem"); // NOI18N
        fixedTerminalSizeMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fixedTerminalSizeMenuItemActionPerformed(evt);
            }
        });
        terminalSizeMenuItem.add(fixedTerminalSizeMenuItem);

        viewMenu.add(terminalSizeMenuItem);

        encodingMenu.setMnemonic('e');
        encodingMenu.setText("Encoding");
        encodingMenu.setName("encodingMenu"); // NOI18N

        encodingButtonGroup.add(autodetectEncodingMenuItem);
        autodetectEncodingMenuItem.setMnemonic('a');
        autodetectEncodingMenuItem.setSelected(true);
        autodetectEncodingMenuItem.setText("Autodetect");
        autodetectEncodingMenuItem.setEnabled(false);
        autodetectEncodingMenuItem.setName("autodetectEncodingMenuItem"); // NOI18N
        autodetectEncodingMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                autodetectEncodingMenuItemStateChanged(evt);
            }
        });
        encodingMenu.add(autodetectEncodingMenuItem);

        encodingButtonGroup.add(unicodeEncodingMenuItem);
        unicodeEncodingMenuItem.setMnemonic('u');
        unicodeEncodingMenuItem.setText("Unicode (UTF-8)");
        unicodeEncodingMenuItem.setEnabled(false);
        unicodeEncodingMenuItem.setName("unicodeEncodingMenuItem"); // NOI18N
        unicodeEncodingMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                unicodeEncodingMenuItemStateChanged(evt);
            }
        });
        encodingMenu.add(unicodeEncodingMenuItem);

        encodingButtonGroup.add(ibmEncodingMenuItem);
        ibmEncodingMenuItem.setMnemonic('i');
        ibmEncodingMenuItem.setText("IBM (IBM850)");
        ibmEncodingMenuItem.setEnabled(false);
        ibmEncodingMenuItem.setName("ibmEncodingMenuItem"); // NOI18N
        ibmEncodingMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                ibmEncodingMenuItemStateChanged(evt);
            }
        });
        encodingMenu.add(ibmEncodingMenuItem);

        encodingButtonGroup.add(latin1EncodingMenuItem);
        latin1EncodingMenuItem.setMnemonic('l');
        latin1EncodingMenuItem.setText("Latin-1 (ISO-8859-1)");
        latin1EncodingMenuItem.setEnabled(false);
        latin1EncodingMenuItem.setName("latin1EncodingMenuItem"); // NOI18N
        latin1EncodingMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                latin1EncodingMenuItemStateChanged(evt);
            }
        });
        encodingMenu.add(latin1EncodingMenuItem);

        viewMenu.add(encodingMenu);

        antialiasingMenu.setMnemonic('a');
        antialiasingMenu.setText("Antialiasing");
        antialiasingMenu.setName("antialiasingMenu"); // NOI18N

        antialiasButtonGroup.add(antialiasingOffMenuItem);
        antialiasingOffMenuItem.setMnemonic('o');
        antialiasingOffMenuItem.setText("Off");
        antialiasingOffMenuItem.setName("antialiasingOffMenuItem"); // NOI18N
        antialiasingOffMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                antialiasingOffMenuItemStateChanged(evt);
            }
        });
        antialiasingMenu.add(antialiasingOffMenuItem);

        antialiasButtonGroup.add(antialiasingDefaultMenuItem);
        antialiasingDefaultMenuItem.setMnemonic('d');
        antialiasingDefaultMenuItem.setSelected(true);
        antialiasingDefaultMenuItem.setText("Default");
        antialiasingDefaultMenuItem.setName("antialiasingDefaultMenuItem"); // NOI18N
        antialiasingDefaultMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                antialiasingDefaultMenuItemStateChanged(evt);
            }
        });
        antialiasingMenu.add(antialiasingDefaultMenuItem);

        antialiasButtonGroup.add(antialiasingRGBMenuItem);
        antialiasingRGBMenuItem.setMnemonic('s');
        antialiasingRGBMenuItem.setText("Subpixel (RGB)");
        antialiasingRGBMenuItem.setName("antialiasingRGBMenuItem"); // NOI18N
        antialiasingRGBMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                antialiasingRGBMenuItemStateChanged(evt);
            }
        });
        antialiasingMenu.add(antialiasingRGBMenuItem);

        antialiasButtonGroup.add(antialiasingBGRMenuItem);
        antialiasingBGRMenuItem.setMnemonic('b');
        antialiasingBGRMenuItem.setText("Subpixel (BGR)");
        antialiasingBGRMenuItem.setName("antialiasingBGRMenuItem"); // NOI18N
        antialiasingBGRMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                antialiasingBGRMenuItemStateChanged(evt);
            }
        });
        antialiasingMenu.add(antialiasingBGRMenuItem);

        viewMenu.add(antialiasingMenu);

        setFontMenuItem.setMnemonic('s');
        setFontMenuItem.setText("Set Font...");
        setFontMenuItem.setName("setFontMenuItem"); // NOI18N
        setFontMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                setFontMenuItemActionPerformed(evt);
            }
        });
        viewMenu.add(setFontMenuItem);

        menuBar.add(viewMenu);

        goMenu.setMnemonic('g');
        goMenu.setText("Go");
        goMenu.setName("goMenu"); // NOI18N

        playPauseMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_SPACE, 0));
        playPauseMenuItem.setMnemonic('p');
        playPauseMenuItem.setText("Play");
        playPauseMenuItem.setEnabled(false);
        playPauseMenuItem.setName("playPauseMenuItem"); // NOI18N
        playPauseMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                updatePlayPaused(evt);
            }
        });
        goMenu.add(playPauseMenuItem);

        jSeparator1.setName("jSeparator1"); // NOI18N
        goMenu.add(jSeparator1);

        startMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_HOME, 0));
        startMenuItem.setMnemonic('t');
        startMenuItem.setText("To Start");
        startMenuItem.setEnabled(false);
        startMenuItem.setName("startMenuItem"); // NOI18N
        startMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goToStart(evt);
            }
        });
        goMenu.add(startMenuItem);

        endMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_END, 0));
        endMenuItem.setMnemonic('e');
        endMenuItem.setText("To End");
        endMenuItem.setEnabled(false);
        endMenuItem.setName("endMenuItem"); // NOI18N
        endMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goToEnd(evt);
            }
        });
        goMenu.add(endMenuItem);

        backwardFrameMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_LEFT, 0));
        backwardFrameMenuItem.setMnemonic('b');
        backwardFrameMenuItem.setText("Back One Frame");
        backwardFrameMenuItem.setEnabled(false);
        backwardFrameMenuItem.setName("backwardFrameMenuItem"); // NOI18N
        backwardFrameMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goBackOneFrame(evt);
            }
        });
        goMenu.add(backwardFrameMenuItem);

        forwardFrameMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_RIGHT, 0));
        forwardFrameMenuItem.setMnemonic('f');
        forwardFrameMenuItem.setText("Forward One Frame");
        forwardFrameMenuItem.setEnabled(false);
        forwardFrameMenuItem.setName("forwardFrameMenuItem"); // NOI18N
        forwardFrameMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goForwardOneFrame(evt);
            }
        });
        goMenu.add(forwardFrameMenuItem);

        goToSpecificFrameMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G, 0));
        goToSpecificFrameMenuItem.setMnemonic('a');
        goToSpecificFrameMenuItem.setText("To Frame...");
        goToSpecificFrameMenuItem.setEnabled(false);
        goToSpecificFrameMenuItem.setName("goToSpecificFrameMenuItem"); // NOI18N
        goToSpecificFrameMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goToSpecificFrameMenuItemActionPerformed(evt);
            }
        });
        goMenu.add(goToSpecificFrameMenuItem);

        jSeparator3.setName("jSeparator3"); // NOI18N
        goMenu.add(jSeparator3);

        goQuickerMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_UP, 0));
        goQuickerMenuItem.setMnemonic('q');
        goQuickerMenuItem.setText("Quicker");
        goQuickerMenuItem.setName("goQuickerMenuItem"); // NOI18N
        goQuickerMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goQuickerMenuItemActionPerformed(evt);
            }
        });
        goMenu.add(goQuickerMenuItem);

        goSlowerMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DOWN, 0));
        goSlowerMenuItem.setMnemonic('s');
        goSlowerMenuItem.setText("Slower");
        goSlowerMenuItem.setName("goSlowerMenuItem"); // NOI18N
        goSlowerMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goSlowerMenuItemActionPerformed(evt);
            }
        });
        goMenu.add(goSlowerMenuItem);

        goTimesOneMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_1, 0));
        goTimesOneMenuItem.setMnemonic('n');
        goTimesOneMenuItem.setText("Normal Speed");
        goTimesOneMenuItem.setName("goTimesOneMenuItem"); // NOI18N
        goTimesOneMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goTimesOneMenuItemActionPerformed(evt);
            }
        });
        goMenu.add(goTimesOneMenuItem);

        goRewindMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_R, 0));
        goRewindMenuItem.setMnemonic('r');
        goRewindMenuItem.setText("Reverse Direction");
        goRewindMenuItem.setName("goRewindMenuItem"); // NOI18N
        goRewindMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goRewindMenuItemActionPerformed(evt);
            }
        });
        goMenu.add(goRewindMenuItem);

        autoskipMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_L, 0));
        autoskipMenuItem.setMnemonic('k');
        autoskipMenuItem.setText("Skip Inactivity");
        autoskipMenuItem.setName("autoskipMenuItem"); // NOI18N
        autoskipMenuItem.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                autoskipMenuItemStateChanged(evt);
            }
        });
        goMenu.add(autoskipMenuItem);

        menuBar.add(goMenu);

        helpMenu.setMnemonic('h');
        helpMenu.setText("Help");
        helpMenu.setName("helpMenu"); // NOI18N

        aboutMenuItem.setMnemonic('a');
        aboutMenuItem.setText("About...");
        aboutMenuItem.setName("aboutMenuItem"); // NOI18N
        aboutMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                aboutMenuItemActionPerformed(evt);
            }
        });
        helpMenu.add(aboutMenuItem);

        licenceMenuItem.setMnemonic('l');
        licenceMenuItem.setText("Licence information...");
        licenceMenuItem.setName("licenceMenuItem"); // NOI18N
        licenceMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                licenceMenuItemActionPerformed(evt);
            }
        });
        helpMenu.add(licenceMenuItem);

        menuBar.add(helpMenu);

        setJMenuBar(menuBar);
    }// </editor-fold>//GEN-END:initComponents


    /**
     * A function that runs when the Open menu item is selected, that opens
     * a ttyrec file.
     * @param evt Information on which event was performed
     */
    private void openMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openMenuItemActionPerformed
        InputStreamable iStream = null;
        try {
            File f = null;
            JFileChooser fileChooser = new JFileChooser(lastDirectory);
            fileChooser.setAcceptAllFileFilterUsed(false);
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".rec") ||
                           f.getName().toLowerCase().endsWith(".ttyrec") ||
                           f.getName().toLowerCase().endsWith(".ttyrec2") ||
                           f.getName().toLowerCase().endsWith(".rec.gz") ||
                           f.getName().toLowerCase().endsWith(".ttyrec.gz") ||
                           f.getName().toLowerCase().endsWith(".ttyrec2.gz") ||
                           f.getName().toLowerCase().endsWith(".rec.bz2") ||
                           f.getName().toLowerCase().endsWith(".ttyrec.bz2") ||
                           f.getName().toLowerCase().endsWith(".ttyrec2.bz2") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "All supported file extensions";
                }
            });
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".rec") ||
                           f.getName().toLowerCase().endsWith(".ttyrec") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "Ttyrec files (*.rec, *.ttyrec)";
                }
            });
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".ttyrec2") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "Annotated ttyrec files (*.ttyrec2)";
                }
            });
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".ttyrec.gz") ||
                           f.getName().toLowerCase().endsWith(".ttyrec.bz2") ||
                           f.getName().toLowerCase().endsWith(".rec.gz") ||
                           f.getName().toLowerCase().endsWith(".rec.bz2") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "Compressed ttyrec files (*.{ttyrec,rec}.{gz,bz2})";
                }
            });
            fileChooser.addChoosableFileFilter(new FileFilter() {
                /**
                 * Checks the extension on a file to see if it is a ttyrec
                 * file.
                 * @return true if the file has an acceptable extension,
                 *         or is a directory
                 */
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(".ttyrec2.gz") ||
                           f.getName().toLowerCase().endsWith(".ttyrec2.bz2") ||
                           f.isDirectory();
                }
                /**
                 * @return The description of this file filter.
                 */
                @Override
                public String getDescription() {
                    return "Compressed annotated ttyrec files (*.ttyrec2.{gz,bz2})";
                }
            });
            fileChooser.addChoosableFileFilter(fileChooser.getAcceptAllFileFilter());
            
            if (fileChooser.showOpenDialog(mainPanel) != JFileChooser.APPROVE_OPTION) {
                return;
            }
            f = fileChooser.getSelectedFile();
            iStream = new InputStreamableFileWrapper(f);
            lastDirectory = f.getParentFile();
        } catch (java.security.AccessControlException ex) {
            try {
                // Try using a JNLP service to open a file. This is done using
                // reflection so it works even without a JNLP library present.

                // FileOpenService fos = (FileOpenService) ServiceManager.lookup("javax.jnlp.FileOpenService");
                Object fos = getClass().getClassLoader().loadClass("javax.jnlp.ServiceManager").
                             getMethod("lookup", String.class).invoke(null, "javax.jnlp.FileOpenService");
                // FileContents fc = fos.openFileDialog("", new String[]{"rec","ttyrec"});
                Object fc = getClass().getClassLoader().loadClass("javax.jnlp.FileOpenService").
                             getMethod("openFileDialog", String.class, String[].class).
                             invoke(fos, "", new String[]{
                    "rec","ttyrec","ttyrec2","rec.gz","ttyrec.gz","rec.bz2","ttyrec.bz2"});
                if (fc == null) return;
                iStream = new InputStreamableFileContentsWrapper(fc);
                if (iStream == null) throw new IOException();
            } catch (ClassNotFoundException | NoSuchMethodException |
                     SecurityException | IllegalAccessException |
                     IllegalArgumentException | InvocationTargetException | IOException ex1) {
                return;
            }
        }
        if (iStream == null) return;
        openSourceFromInputStreamable(iStream);
    }//GEN-LAST:event_openMenuItemActionPerformed

    private void timeSliderStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_timeSliderStateChanged
        if (getCurrentTtyrec() == null) return;
        setTimeLabels();
        int i = getCurrentTtyrec().getFrameIndexAtRelativeTime(
                (double) timeSlider.getValue() / timeScaling);
        if (canUpdateSelectedFrame)
            goToSpecificFrame(i, false);
        else
            canUpdateSelectedFrame = true;
        if (!canUpdateTimeStartedAt) {
            canUpdateTimeStartedAt = true;
            return;
        }
        timeStartedAt = new Date().getTime();
        sliderValueStartedAt = timeSlider.getValue();
    }//GEN-LAST:event_timeSliderStateChanged

    private void updatePlayPaused(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_updatePlayPaused
        if (getCurrentTtyrec() == null) return;
        playing = playPauseMenuItem.isSelected();
        if (playing) {
            timeStartedAt = new Date().getTime();
            sliderValueStartedAt = timeSlider.getValue();
            if ((Double)speedSpinner.getValue() == 0)
                speedSpinner.setValue(1.0);
            playTimer.restart();
        } else
            playTimer.stop();
        if (playPauseMenuItem.isSelected() != playButton.isSelected())
            playButton.setSelected(playPauseMenuItem.isSelected());
        updateSidebar();
    }//GEN-LAST:event_updatePlayPaused

    private void playButtonChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_playButtonChanged
        if (playPauseMenuItem.isSelected() != playButton.isSelected())
            playPauseMenuItem.setSelected(playButton.isSelected());
    }//GEN-LAST:event_playButtonChanged

    private void goToStart(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goToStart
        goToSpecificFrame(0, true);
    }//GEN-LAST:event_goToStart

    private void goToEnd(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goToEnd
        // The time of the last frame might not equal the end of the recording
        // if we're streaming. And the end of the recording might not equal the
        // time of the last frame if the recording ends with two frames less
        // than a millisecond apart. So the solution is to set both separately.
        timeSlider.setValue(timeSlider.getMaximum());
        goToSpecificFrame(getCurrentTtyrec().getFrameCount()-1, false);
    }//GEN-LAST:event_goToEnd

    private void goBackOneFrame(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goBackOneFrame
        goToSpecificFrame(previousFrameIndex-1, true);
    }//GEN-LAST:event_goBackOneFrame

    private void goForwardOneFrame(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goForwardOneFrame
        goToSpecificFrame(previousFrameIndex+1, true);
    }//GEN-LAST:event_goForwardOneFrame

    private void licenceMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_licenceMenuItemActionPerformed
        new JettyLicence(this).setVisible(true);
    }//GEN-LAST:event_licenceMenuItemActionPerformed

    private void autoskipButtonStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_autoskipButtonStateChanged
        autoskipMenuItem.setSelected(autoskipButton.isSelected());
        updateSidebar();
    }//GEN-LAST:event_autoskipButtonStateChanged

    private void autoskipMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_autoskipMenuItemStateChanged
        autoskipButton.setSelected(autoskipMenuItem.isSelected());
        updateSidebar();
    }//GEN-LAST:event_autoskipMenuItemStateChanged

    private void unicodeEncodingMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_unicodeEncodingMenuItemStateChanged
        if (unicodeEncodingMenuItem.isSelected())
            setTtyrecFormat(Ttyrec.Encoding.UTF8);
    }//GEN-LAST:event_unicodeEncodingMenuItemStateChanged

    private void ibmEncodingMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_ibmEncodingMenuItemStateChanged
        if (ibmEncodingMenuItem.isSelected())
            setTtyrecFormat(Ttyrec.Encoding.IBM);
    }//GEN-LAST:event_ibmEncodingMenuItemStateChanged

    private void latin1EncodingMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_latin1EncodingMenuItemStateChanged
        if (latin1EncodingMenuItem.isSelected())
            setTtyrecFormat(Ttyrec.Encoding.Latin1);
    }//GEN-LAST:event_latin1EncodingMenuItemStateChanged

    private void fullScreenMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_fullScreenMenuItemStateChanged
        GraphicsEnvironment.getLocalGraphicsEnvironment().
                getDefaultScreenDevice().setFullScreenWindow(
                fullScreenMenuItem.isSelected() ?
                    this : null);
    }//GEN-LAST:event_fullScreenMenuItemStateChanged

    private void sidebarMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sidebarMenuItemStateChanged
        sidebarToolbar.setVisible(sidebarMenuItem.isSelected());
    }//GEN-LAST:event_sidebarMenuItemStateChanged

    private void toolBarMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_toolBarMenuItemStateChanged
        mainToolbar.setVisible(toolBarMenuItem.isSelected());
    }//GEN-LAST:event_toolBarMenuItemStateChanged

    private void menuBarMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_menuBarMenuItemStateChanged
        if (menuBarMenuItem.isSelected()) {
            if (!menuBarShowing) {
                //menuBar.setPreferredSize(new Dimension(32767,savedMenuBarHeight));
                menuBar.setPreferredSize(null);
                menuBar.setVisible(false);
                menuBar.setVisible(true);
                menuBarShowing = true;
            }
        } else {
            if (menuBarShowing) {
                menuBar.setPreferredSize(new Dimension(32767,1));
                menuBar.setVisible(false);
                menuBar.setVisible(true);
                menuBarShowing = false;
            }
        }
    }//GEN-LAST:event_menuBarMenuItemStateChanged

    private void controlBarMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_controlBarMenuItemStateChanged
        timePanel.setVisible(controlBarMenuItem.isSelected());
    }//GEN-LAST:event_controlBarMenuItemStateChanged

    private void antialiasingOffMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_antialiasingOffMenuItemStateChanged
        if(antialiasingOffMenuItem.isSelected())
            replayTerminal.setTextAntialiasingType(RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
    }//GEN-LAST:event_antialiasingOffMenuItemStateChanged

    private void antialiasingDefaultMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_antialiasingDefaultMenuItemStateChanged
        if(antialiasingDefaultMenuItem.isSelected())
            replayTerminal.setTextAntialiasingType(RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    }//GEN-LAST:event_antialiasingDefaultMenuItemStateChanged

    private void antialiasingRGBMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_antialiasingRGBMenuItemStateChanged
        if(antialiasingRGBMenuItem.isSelected())
            replayTerminal.setTextAntialiasingType(safelyGetRenderingHint("VALUE_TEXT_ANTIALIAS_LCD_HRGB"));
    }//GEN-LAST:event_antialiasingRGBMenuItemStateChanged

    private void antialiasingBGRMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_antialiasingBGRMenuItemStateChanged
        if(antialiasingBGRMenuItem.isSelected())
            replayTerminal.setTextAntialiasingType(safelyGetRenderingHint("VALUE_TEXT_ANTIALIAS_LCD_HBGR"));
    }//GEN-LAST:event_antialiasingBGRMenuItemStateChanged

    private void goRewindMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goRewindMenuItemActionPerformed
        speedSpinner.setValue((Double)speedSpinner.getValue() * -1.0);
    }//GEN-LAST:event_goRewindMenuItemActionPerformed

    private void goTimesOneMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goTimesOneMenuItemActionPerformed
        speedSpinner.setValue(1.0);
    }//GEN-LAST:event_goTimesOneMenuItemActionPerformed

    private void goSlowerMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goSlowerMenuItemActionPerformed
        if (!((Double)speedSpinner.getValue()).equals(1.0))
            speedSpinner.setValue((Double)speedSpinner.getValue() - 1.0);
        else
            speedSpinner.setValue(-1.0);
    }//GEN-LAST:event_goSlowerMenuItemActionPerformed

    private void goQuickerMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goQuickerMenuItemActionPerformed
        if (!((Double)speedSpinner.getValue()).equals(-1.0))
            speedSpinner.setValue((Double)speedSpinner.getValue() + 1.0);
        else
            speedSpinner.setValue(1.0);
    }//GEN-LAST:event_goQuickerMenuItemActionPerformed

    private void goToSpecificFrameMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goToSpecificFrameMenuItemActionPerformed
        String frameString = JOptionPane.showInputDialog(
                encodingMenu, "Go to which frame?", ""+(previousFrameIndex+1));
        if (frameString == null) return;
        try {
            goToSpecificFrame(Integer.valueOf(frameString) - 1, true);
        } catch (NumberFormatException ex) {
            // ignore invalid input
        }
    }//GEN-LAST:event_goToSpecificFrameMenuItemActionPerformed

    private void findMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findMenuItemActionPerformed
        if (findBox == null)
            findBox = new JettyFind(this,this);
        findBox.setVisible(true);
        findBox.fixDefaultFocus();
        findBox.requestFocusInWindow();
    }//GEN-LAST:event_findMenuItemActionPerformed

    private void plainTextScreenshotMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_plainTextScreenshotMenuItemActionPerformed
        VDUBuffer vdub = null;
        if (getCurrentTtyrec() != null) vdub = getCurrentFrame().getTerminalState();
        if (vdub == null) vdub = new vt320();
        StringBuilder sb = new StringBuilder();
        for (char[] s: vdub.charArray) {
            sb.append(s);
            sb.append('\n');
        }
        setClipboardContents(new StringSelection(sb.toString()));
    }//GEN-LAST:event_plainTextScreenshotMenuItemActionPerformed

    private void htmlScreenshotMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_htmlScreenshotMenuItemActionPerformed
        final String s = replayTerminal.asHTML();
        setClipboardContents(new DataHandler(new DataSource() {
            public InputStream getInputStream() throws IOException {
                return new ByteArrayInputStream(s.getBytes());
            }
            public OutputStream getOutputStream() throws IOException {
                throw new IOException("Cannot write to a screenshot");
            }
            public String getContentType() {
                return "text/html";
            }
            public String getName() {
                return "Jettyplay Screenshot";
            }
        }));
    }//GEN-LAST:event_htmlScreenshotMenuItemActionPerformed

    private void imageScreenshotMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_imageScreenshotMenuItemActionPerformed
        // Prepare a stream for writing the image data to
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            String mime;
            try (ImageOutputStream ios = new MemoryCacheImageOutputStream(baos)) {
                String[] mimes = ImageIO.getWriterMIMETypes();
                if (mimes.length == 0) {
                    JOptionPane.showMessageDialog(screenshotMenu,
                            "No image encoders found", "Jettyplay",
                            JOptionPane.ERROR_MESSAGE);
                    return;
                }
                mime = mimes[0];
                Arrays.sort(mimes);
                if (Arrays.binarySearch(mimes, "image/png") > 0) // #NOI18N
                    mime = "image/png";
                ImageWriter iw = ImageIO.getImageWritersByMIMEType(mime).next();
                iw.setOutput(ios);
                if (antialiasingBGRMenuItem.isSelected() ||
                    antialiasingRGBMenuItem.isSelected())
                    replayTerminal.setTextAntialiasingType(RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
                BufferedImage bi = new BufferedImage(
                        replayTerminal.getCurrentTerminalWidth(),
                        replayTerminal.getCurrentTerminalHeight(),
                        BufferedImage.TYPE_INT_RGB);
                replayTerminal.redraw(bi.createGraphics(),
                        bi.getWidth(), bi.getHeight());
                iw.write(bi);
                antialiasingBGRMenuItemStateChanged(null);
                antialiasingRGBMenuItemStateChanged(null);
            }
            final String mime_final = mime;
            final byte[] byteStream = baos.toByteArray();
            DataSource ds = new DataSource() {
                public InputStream getInputStream() throws IOException {
                    return new ByteArrayInputStream(byteStream);
                }
                public OutputStream getOutputStream() throws IOException {
                    throw new IOException("Cannot write to a screenshot");
                }
                public String getContentType() {
                    return mime_final;
                }
                public String getName() {
                    return "Jettyplay Screenshot";
                }
            };
            setClipboardContents(new DataHandler(ds));
        } catch (IOException ex) {
            return;
        }
    }//GEN-LAST:event_imageScreenshotMenuItemActionPerformed

    private void speedSpinnerStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_speedSpinnerStateChanged
        if ((((Double)speedSpinner.getValue()).equals(0.0)) && playing) {
            playPauseMenuItem.setSelected(false);
            playButton.setSelected(false);
            playing = false;
            playTimer.stop();
        }
        sliderValueStartedAt = timeSlider.getValue();
        timeStartedAt = new Date().getTime();
        updateSidebar();
    }//GEN-LAST:event_speedSpinnerStateChanged

    private void sidebarTypeComboBoxAncestorResized(java.awt.event.HierarchyEvent evt) {//GEN-FIRST:event_sidebarTypeComboBoxAncestorResized
        int oldOrientation = sidebarToolbar.getOrientation();
        sidebarToolbar.setLayout(new BoxLayout(sidebarToolbar,
                oldOrientation == SwingConstants.HORIZONTAL ?
                    BoxLayout.X_AXIS : BoxLayout.Y_AXIS));
        // fix layout
        sidebarToolbar.invalidate();
        sidebarToolbar.validate();
        // fix sizing (by forcing a size recalculation)
        sidebarToolbar.setOrientation(SwingConstants.HORIZONTAL);
        sidebarToolbar.setOrientation(SwingConstants.VERTICAL);
        sidebarToolbar.setOrientation(oldOrientation);
        sidebarPane.setVertical(oldOrientation == SwingConstants.VERTICAL);
    }//GEN-LAST:event_sidebarTypeComboBoxAncestorResized

    private void sidebarTypeComboBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_sidebarTypeComboBoxItemStateChanged
        updateSidebar();
    }//GEN-LAST:event_sidebarTypeComboBoxItemStateChanged

    private void speedSpinnerMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_speedSpinnerMouseClicked
        String frameString = JOptionPane.showInputDialog(
                encodingMenu, "Set speed to what?", ""+(speedSpinner.getValue()));
        if (frameString == null) return;
        try {
            speedSpinner.setValue(Double.valueOf(frameString));
        } catch (NumberFormatException ex) {
            // ignore invalid input
        }
    }//GEN-LAST:event_speedSpinnerMouseClicked

    private void aboutMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aboutMenuItemActionPerformed
        new JettyAboutBox(this).setVisible(true);
    }//GEN-LAST:event_aboutMenuItemActionPerformed

    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitMenuItemActionPerformed

    private void autodetectEncodingMenuItemStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_autodetectEncodingMenuItemStateChanged
        if (autodetectEncodingMenuItem.isSelected())
            getCurrentTtyrec().resetEncoding();
    }//GEN-LAST:event_autodetectEncodingMenuItemStateChanged

    private void openURLMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openURLMenuItemActionPerformed
        try {
            URL u = new URL(JOptionPane.showInputDialog(
                    fileMenu, "Open which URL?"));
            openSourceFromInputStreamable(new InputStreamableURLWrapper(u));
        } catch (MalformedURLException ex) {
            System.out.println(ex.getMessage());
            return;
        } catch (NullPointerException ex) {
            return;
        }
    }//GEN-LAST:event_openURLMenuItemActionPerformed

    private void setFontMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_setFontMenuItemActionPerformed
        JettyFont fontBox = new JettyFont(this,this);
        fontBox.setVisible(true);
        fontBox.fixDefaultFocus();
        fontBox.requestFocusInWindow();
    }//GEN-LAST:event_setFontMenuItemActionPerformed

    private void autodetectTerminalSizeMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_autodetectTerminalSizeMenuItemActionPerformed
        getCurrentTtyrec().setForcedSize(-1,-1);
        autodetectTerminalSizeMenuItem.setSelected(true);
        fixedTerminalSizeMenuItem.setSelected(false);
        getCurrentSource().repeatCurrentDecodeWorker();
    }//GEN-LAST:event_autodetectTerminalSizeMenuItemActionPerformed

    private void fixedTerminalSizeMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fixedTerminalSizeMenuItemActionPerformed
        String s = JOptionPane.showInputDialog(viewMenu,
                "Fix terminal window at what size (WxH)?", "80x24");
        if (s == null) return;
        setForcedSizeFromString(s);
    }//GEN-LAST:event_fixedTerminalSizeMenuItemActionPerformed

    private void setForcedSizeFromString(String s) {
        Matcher m = Pattern.compile("\\s*(\\d+)\\s*x\\s*(\\d+)\\s*").
                matcher(s);
        if (!m.matches()) return;
        getCurrentTtyrec().setForcedSize(
                Integer.valueOf(m.group(1)), Integer.valueOf(m.group(2)));
        autodetectTerminalSizeMenuItem.setSelected(false);
        fixedTerminalSizeMenuItem.setSelected(true);
        getCurrentSource().repeatCurrentDecodeWorker();
    }

    private void setClipboardContents(Transferable t) {
        try {
            this.getToolkit().
                    getSystemClipboard().setContents(t, this);
        } catch (java.security.AccessControlException ex) {
            try {
                // Try using a JNLP service to access the clipboard.

                // ClipboardService cs = (ClipboardService) ServiceManager.lookup("javax.jnlp.ClipboardService");
                Object cs = getClass().getClassLoader().loadClass("javax.jnlp.ServiceManager").
                            getMethod("lookup", String.class).invoke(null, "javax.jnlp.ClipboardService");
                // cs.setContents(t);
                getClass().getClassLoader().loadClass("javax.jnlp.ClipboardService").
                            getMethod("setContents", Transferable.class).invoke(cs, t);
            } catch (ClassNotFoundException | NoSuchMethodException |
                     SecurityException | IllegalAccessException |
                     IllegalArgumentException | InvocationTargetException ex1) {
                return;
            }
        }
    }

    private void syncAntialiasingWithMenu() {
        antialiasingOffMenuItemStateChanged(null);
        antialiasingDefaultMenuItemStateChanged(null);
        antialiasingRGBMenuItemStateChanged(null);
        antialiasingBGRMenuItemStateChanged(null);
    }

    private void setTtyrecFormat(Ttyrec.Encoding format) {
        if (getCurrentTtyrec() == null) return;
        if (getCurrentTtyrec().getEncoding() == format) return;
        getCurrentTtyrec().setEncoding(format);
        getCurrentSource().repeatCurrentDecodeWorker();
    }

    private void goToSpecificFrame(int frame, boolean changeTimeSlider) {
        if (getCurrentTtyrec() == null) return;
        if (frame < 0 || frame >= getCurrentTtyrec().getFrameCount()) return;
        TtyrecFrame f = getCurrentTtyrec().getFrameAtIndex(frame);
        if (changeTimeSlider) {
            timeSlider.setValue((int)Math.ceil(
                    f.getRelativeTimestamp() * timeScaling));
            timeSliderStateChanged(null);
        }
        if (frame != previousFrameIndex) {
            replayTerminal.setVDUBuffer(f.getTerminalState());
            f.setDirty(false);
        }
        previousFrameIndex = frame;
        updateSidebar();
    }

    private String timeToString(double time) {
        int t = (int)time;
        if (t<0) t = 0;
        String s = (t/60) + ":";
        if (t > 3600) {
            s = (t/3600) + ":";
            if ((t/60)%60 < 10) s += "0";
            s += (t/60)%60 + ":";
        }
        if (t%60 < 10) s += "0";
        s += t%60;
        return s;
    }

    private void setTimeLabels() {
        if (getCurrentTtyrec() == null) return;
        maxTime.setText(timeToString(getCurrentTtyrec().getLength()));
        curTime.setPreferredSize(maxTime.getPreferredSize());
        curTime.setText(timeToString((double)timeSlider.getValue() / timeScaling));
    }

    private boolean oldEnabled = false;
    private void massSetEnabled(boolean enabled) {
        if (enabled == oldEnabled) return;
        oldEnabled = enabled;
        playPauseMenuItem.setEnabled(enabled);
        playButton.setEnabled(enabled);
        startMenuItem.setEnabled(enabled);
        startButton.setEnabled(enabled);
        endMenuItem.setEnabled(enabled);
        endButton.setEnabled(enabled);
        forwardFrameMenuItem.setEnabled(enabled);
        forwardFrameButton.setEnabled(enabled);
        backwardFrameMenuItem.setEnabled(enabled);
        backwardFrameButton.setEnabled(enabled);
        goToSpecificFrameMenuItem.setEnabled(enabled);
        findMenuItem.setEnabled(enabled);
        if (!enabled) {
            unicodeEncodingMenuItem.setEnabled(enabled);
            ibmEncodingMenuItem.setEnabled(enabled);
            latin1EncodingMenuItem.setEnabled(enabled);
        }
        autodetectEncodingMenuItem.setEnabled(enabled);
        autodetectTerminalSizeMenuItem.setEnabled(enabled);
        fixedTerminalSizeMenuItem.setEnabled(enabled);
        maxTime.setEnabled(enabled);
        curTime.setEnabled(enabled);
        timeSlider.setEnabled(enabled);
    }

    private void unloadFile() {
        playing = false;
        playTimer.stop();
        playPauseMenuItem.setSelected(false);
        playButton.setSelected(false);
        massSetEnabled(false);
        if (getCurrentSource() != null) getCurrentSource().completeCancel();
        currentSource = null;
        replayTerminal.setVDUBuffer(new vt320());
        maxTime.setText("0:00");
        curTime.setPreferredSize(maxTime.getPreferredSize());
        curTime.setText("0:00");
        timeSlider.setValue(0);
        timeSlider.setMaximum(1);
        timeSlider.repaint();
        VDUBuffer.resetCaches();
        updateSidebar();
    }

    private void openSourceFromInputStreamable(InputStreamable iStream) {
        unloadFile();
        currentSource = new InputStreamTtyrecSource(iStream);
        getCurrentSource().completeUnpause();
        getCurrentSource().addDecodeListener(new ProgressListener() {
            public void progressMade() {
                decodeProgressMade();
            }
        });
        getCurrentSource().addAnalysisListener(new ProgressListener() {
            public void progressMade() {
                analysisProgressMade();
            }
        });
        getCurrentSource().addReadListener(new ProgressListener() {
            public void progressMade() {
                readProgressMade();
            }
        });
        getCurrentSource().start();
        setTimeLabels();
        massSetEnabled(true);
        previousFrameIndex = 0;
        // If viewing an inherently streaming source, set up for streaming;
        // jump to the end and set play mode on.
        if (iStream.mustBeStreamable()) {
            timeSlider.setValue(timeSlider.getMaximum());
            goToSpecificFrame(getCurrentTtyrec().getFrameCount() - 1, false);
            playPauseMenuItem.setSelected(true);
            playButton.setSelected(true);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem aboutMenuItem;
    private javax.swing.ButtonGroup antialiasButtonGroup;
    private javax.swing.JRadioButtonMenuItem antialiasingBGRMenuItem;
    private javax.swing.JRadioButtonMenuItem antialiasingDefaultMenuItem;
    private javax.swing.JMenu antialiasingMenu;
    private javax.swing.JRadioButtonMenuItem antialiasingOffMenuItem;
    private javax.swing.JRadioButtonMenuItem antialiasingRGBMenuItem;
    private javax.swing.JRadioButtonMenuItem autodetectEncodingMenuItem;
    private javax.swing.JRadioButtonMenuItem autodetectTerminalSizeMenuItem;
    private javax.swing.JToggleButton autoskipButton;
    private javax.swing.JCheckBoxMenuItem autoskipMenuItem;
    private javax.swing.JButton backwardFrameButton;
    private javax.swing.JMenuItem backwardFrameMenuItem;
    private javax.swing.JCheckBoxMenuItem controlBarMenuItem;
    private javax.swing.JLabel curTime;
    private javax.swing.JMenu editMenu;
    private javax.swing.ButtonGroup encodingButtonGroup;
    private javax.swing.JMenu encodingMenu;
    private javax.swing.JButton endButton;
    private javax.swing.JMenuItem endMenuItem;
    private javax.swing.JMenuItem exitMenuItem;
    private final javax.swing.JMenu fileMenu = new javax.swing.JMenu();
    private javax.swing.JMenuItem findMenuItem;
    private javax.swing.JRadioButtonMenuItem fixedTerminalSizeMenuItem;
    private javax.swing.JButton forwardFrameButton;
    private javax.swing.JMenuItem forwardFrameMenuItem;
    private javax.swing.JCheckBoxMenuItem fullScreenMenuItem;
    private javax.swing.JMenu goMenu;
    private javax.swing.JMenuItem goQuickerMenuItem;
    private javax.swing.JMenuItem goRewindMenuItem;
    private javax.swing.JMenuItem goSlowerMenuItem;
    private javax.swing.JMenuItem goTimesOneMenuItem;
    private javax.swing.JMenuItem goToSpecificFrameMenuItem;
    private javax.swing.JMenuItem htmlScreenshotMenuItem;
    private javax.swing.JRadioButtonMenuItem ibmEncodingMenuItem;
    private javax.swing.JMenuItem imageScreenshotMenuItem;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JToolBar.Separator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JSeparator jSeparator4;
    private javax.swing.JSeparator jSeparator5;
    private javax.swing.JRadioButtonMenuItem latin1EncodingMenuItem;
    private javax.swing.JMenuItem licenceMenuItem;
    private javax.swing.JPanel mainPanel;
    private javax.swing.JToolBar mainToolbar;
    private javax.swing.JPanel mainToolbarPanel;
    private javax.swing.JLabel maxTime;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JCheckBoxMenuItem menuBarMenuItem;
    private javax.swing.JMenuItem openMenuItem;
    private javax.swing.JMenuItem openURLMenuItem;
    private javax.swing.JMenuItem plainTextScreenshotMenuItem;
    private javax.swing.JToggleButton playButton;
    private javax.swing.JCheckBoxMenuItem playPauseMenuItem;
    private javax.swing.JMenu screenshotMenu;
    private javax.swing.JMenuItem setFontMenuItem;
    private javax.swing.JCheckBoxMenuItem sidebarMenuItem;
    private javax.swing.JToolBar sidebarToolbar;
    private javax.swing.JPanel sidebarToolbarPanel;
    private javax.swing.JComboBox sidebarTypeComboBox;
    private javax.swing.JSpinner speedSpinner;
    private javax.swing.JButton startButton;
    private javax.swing.JMenuItem startMenuItem;
    private javax.swing.JMenu terminalSizeMenuItem;
    private javax.swing.JPanel timePanel;
    private javax.swing.JSlider timeSlider;
    private javax.swing.JCheckBoxMenuItem toolBarMenuItem;
    private javax.swing.JRadioButtonMenuItem unicodeEncodingMenuItem;
    private javax.swing.JMenu viewMenu;
    // End of variables declaration//GEN-END:variables
    private SwingTerminal replayTerminal;
    private JettySidebar sidebarPane;
    private boolean menuBarShowing = true;

    private TtyrecSource currentSource;

    // TODO: Reduce this in the case of excessively time-long ttyrecs,
    // to avoid an integer overflow
    private int timeScaling = 1000;
    private boolean playing = false;
    private final Timer playTimer;
    private final Timer streamingTimer;
    private int previousFrameIndex = -1;
    private long timeStartedAt;
    private int sliderValueStartedAt;
    private boolean canUpdateTimeStartedAt = true;
    private boolean canUpdateSelectedFrame = true;

    private JDialog aboutBox;
    private JettyFind findBox;

    private File lastDirectory = null;
    
    public double getMaximumTime() {
        if (getCurrentTtyrec() == null) return 0.0;
        return getCurrentTtyrec().getLength();
    }
    public double getCurrentTime() {
        if (getCurrentTtyrec() == null) return 0.0;
        if (getCurrentSource().backportDecodeProgress() ==
                getCurrentTtyrec().getFrameCount())
            return getCurrentTtyrec().getLength();
        if (getCurrentSource().backportDecodeProgress() == 0) return 0.0;
        return getCurrentTtyrec().getFrameAtIndex(getCurrentSource().backportDecodeProgress()-1).getRelativeTimestamp();
    }
    public double getFuzzyTime() {
        if (getCurrentTtyrec() == null) return 0.0;
        if (getCurrentSource().decodeProgress() == getCurrentTtyrec().getFrameCount())
            return getCurrentTtyrec().getLength();
        if (getCurrentSource().decodeProgress() == 0) return 0.0;
        return getCurrentTtyrec().getFrameAtIndex(getCurrentSource().decodeProgress()-1).getRelativeTimestamp();
    }

    private void synchSliderMaximum() {
        if (getCurrentTtyrec() == null) return;
        boolean atmax = timeSlider.getValue() == timeSlider.getMaximum();
        canUpdateTimeStartedAt = false;
        canUpdateSelectedFrame = false;
        timeSlider.setMaximum((int) (getCurrentTtyrec().getLength() * timeScaling));
        if (atmax && playing) {
            canUpdateTimeStartedAt = true;
            // to avoid glitches, let the play loop handle updating the
            // selected frame
            canUpdateSelectedFrame = false;
            timeSlider.setValue(timeSlider.getMaximum());
        }
        timeSlider.repaint();        
        updateSidebar();
        setTimeLabels();
    }

    /**
     * A listener that should be called whenever progress has been made in
     * reading an input source for a currently opened ttyrec.
     */
    public void readProgressMade() {
        synchSliderMaximum();
    }

    /**
     * A listener that should be called whenever progress has been made in
     * decoding a currently opened ttyrec.
     */
    public void decodeProgressMade() {
        timeSlider.repaint();
        updateSidebar();
        if (getCurrentTtyrec() != null &&
            getCurrentTtyrec().getFrameCount() > previousFrameIndex &&
            getCurrentFrame().isDirty()) {
            replayTerminal.setVDUBuffer(
                    getCurrentFrame().getTerminalState());
            getCurrentFrame().setDirty(false);
        }
    }

    /**
     * A listener that should be called whenever progress has been made in
     * analysing a currently open ttyrec.
     */
    public void analysisProgressMade() {
        synchSliderMaximum();
        setTimeLabels();
        updateSidebar();
        // Synch the selected encoding from the ttyrec...
        if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.Autodetect)
            autodetectEncodingMenuItem.setSelected(true);
        if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.IBM)
            ibmEncodingMenuItem.setSelected(true);
        if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.Latin1)
            latin1EncodingMenuItem.setSelected(true);
        if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.UTF8)
            unicodeEncodingMenuItem.setSelected(true);
        // /before/ setting which item is enabled, or we'll end up copying
        // the old value over the new one rather than vice versa.
        ibmEncodingMenuItem.setEnabled
            (getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.IBM));
        unicodeEncodingMenuItem.setEnabled
            (getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.UTF8));
        latin1EncodingMenuItem.setEnabled
            (getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.Latin1));
        // if we just decoded the wanted frame, jump to it
        if (getCurrentTtyrec().getWantedFrame() > -1 &&
                getCurrentTtyrec().getFrameCount() >
                getCurrentTtyrec().getWantedFrame()) {
            goToSpecificFrame(getCurrentTtyrec().getWantedFrame(), true);
            getCurrentTtyrec().setWantedFrame(-1);
        }
    }

    private TtyrecFrame getCurrentFrame() {
        try {
            return getCurrentTtyrec().getFrameAtIndex(previousFrameIndex);
        } catch(IndexOutOfBoundsException ex) {
            return null;
        }
    }

    private void setSidebarPropertyMessage() {
        if (getCurrentTtyrec() != null) {
            AttributedString[] as = new AttributedString[7];
            as[0] = new AttributedString(playing ? "Playing" : "Paused");
            as[0].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD);
            double time = (double)timeSlider.getValue() / timeScaling;
            as[1] = new AttributedString("Frame: " + (previousFrameIndex+1) +
                        " / " + getCurrentTtyrec().getFrameCount());
            as[1].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
            as[2] = new AttributedString("Time: " + timeToString(time) +
                        " / " + timeToString(getCurrentTtyrec().getLength()));
            as[2].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,4);
            as[3] = new AttributedString("Speed: x" + speedSpinner.getValue() +
                        (autoskipButton.isSelected() ? " log" : ""));
            as[3].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
            try {
                as[4] = new AttributedString("Size: " +
                        getCurrentFrame().getTerminalState().getColumns() +
                        " x " + getCurrentFrame().getTerminalState().getRows());
            } catch (Exception e) {
                as[4] = new AttributedString("Size: ? x ?");
            }
            as[4].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
            as[5] = new AttributedString("Memory used: " +
                    ((Runtime.getRuntime().totalMemory()) - Runtime.getRuntime().freeMemory()) +
                        " / " + Runtime.getRuntime().maxMemory());
            as[5].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,11);
            try {
                as[6] = new AttributedString("URI: " + getCurrentSource().getURI().toString());
            } catch (URISyntaxException ex) {
                as[6] = new AttributedString("URI: unknown");
            }
            as[6].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,3);
            setSidebarPaneContents(as);
        } else {
            setSidebarPaneContents(new AttributedString[]
                        {new AttributedString("No file loaded.")});
        }
    }

    /**
     * Searches for a given string in the currently open ttyrec; if it's found,
     * then seeks the current ttyrec to the frame where it was found.
     * @param searchFor The string to search for.
     * @param searchForward Whether to search forwards (true) or backwards (false).
     * @param regex Whether the string to search for is actually a regex.
     * @param ignoreCase Whether to do a case-insensitive (true) or case-sensitive (false) search.
     * @param wrapAround Whether to restart the search at one end of the ttyrec if it's finished at the other end.
     * @return A string that can be displayed to the user, summarising the results of the search.
     */
    public String searchInTtyrec(String searchFor, boolean searchForward,
            boolean regex, boolean ignoreCase, boolean wrapAround) {
        Pattern p;
        try {
            // Regex.LITERAL would be nice, but it's too new. So we quote the
            // regex by hand, according to Perl 5 quoting rules; all letters
            // and all digits are left as-is, other characters are preceded by
            // a backslash.
            if (!regex) {
                StringBuilder sb = new StringBuilder();
                for (char c: searchFor.toCharArray()) {
                    if (!Character.isLetter(c) && !Character.isDigit(c))
                        sb.append('\\');
                    sb.append(c);
                }
                searchFor = sb.toString();
            }
            p = Pattern.compile(searchFor, (ignoreCase ? Pattern.CASE_INSENSITIVE : 0));
        } catch (PatternSyntaxException e) {
            return "Invalid regular expression.";
        }
        for (int i = previousFrameIndex;
                i < getCurrentTtyrec().getFrameCount() && i >= 0; i += searchForward ? 1 : -1) {
            if (i == previousFrameIndex) {
                continue;
            }
            if (getCurrentTtyrec().getFrameAtIndex(i).containsPattern(p)) {
                goToSpecificFrame(i, true);
                return "Found at frame " + i + ".";
            }
        }
        if (wrapAround) {
            for (int i = searchForward ? 0 : getCurrentTtyrec().getFrameCount() - 1;
                    i != previousFrameIndex;
                    i += searchForward ? 1 : -1) {
                if (getCurrentTtyrec().getFrameAtIndex(i).containsPattern(p)) {
                    goToSpecificFrame(i, true);
                    return "Found at frame " + i + " (wrapped).";
                }
            }
        }
        return "Match not found.";
    }

    /**
     * A listener called when the window loses clipboard ownership.
     * @param clipboard The clipboard whose ownership was lost.
     * @param contents The contents of the lost clipboard.
     */
    public void lostOwnership(Clipboard clipboard, Transferable contents) {
        // We don't care.
    }

    private void setSidebarPaneContents(AttributedString[] string) {
        sidebarPane.setStartToEnd(true);
        sidebarPane.setContents(Arrays.asList(string));
    }

    static int sidebarUpdates = 0;
    private void updateSidebar() {
        // Java is rather bad at garbage-collecting the text used for the
        // sidebar labels, for some reason. So every 100000 sidebar updates,
        // we run GC by hand.
        sidebarUpdates++;
        if (sidebarUpdates >= 100000) {
            sidebarUpdates = 0;
            System.gc();
        }
        // TODO: Fix magic numbers.
        // 0 = properties; 1 = annotations; 2 = playlist; 3 = raw data
        if (sidebarTypeComboBox.getSelectedIndex() == 0)
            setSidebarPropertyMessage();
        if (sidebarTypeComboBox.getSelectedIndex() == 1) {
            if (getCurrentTtyrec() == null || getCurrentFrame() == null) {
                sidebarPane.setStartToEnd(true);
                setSidebarPaneContents(new AttributedString[]
                {new AttributedString("No file loaded.")});
            } else if (getCurrentTtyrec().getFileType() == Ttyrec.FileType.Ttyrec) {
                sidebarPane.setStartToEnd(true);
                setSidebarPaneContents(new AttributedString[]
                    {new AttributedString("No annotations available.")});
            } else {
                sidebarPane.setStartToEnd(false);
                sidebarPane.setContents(getCurrentFrame().
                        getRawDataIterator((double)timeSlider.getValue()
                                              / timeScaling, 1));
            }
        }
        if (sidebarTypeComboBox.getSelectedIndex() == 3) {
            if (getCurrentTtyrec() == null || getCurrentFrame() == null) {
                sidebarPane.setStartToEnd(true);
                setSidebarPaneContents(new AttributedString[]
                    {new AttributedString("No file loaded.")});
            } else {
                sidebarPane.setStartToEnd(false);
                sidebarPane.setContents(getCurrentFrame().
                        getRawDataIterator((double)timeSlider.getValue()
                                              / timeScaling, 0));
            }
        }
    }

    /**
     * Gets the currently visible ttyrec source; that's the selected source from
     * the playlist.
     * @return the currently selected ttyrec source.
     */
    private TtyrecSource getCurrentSource() {
        return currentSource;
    }


    /**
     * Returns the currently viewed ttyrec.
     * Even if more than one ttyrec is open, only the one currently showing is
     * returned.
     * @return The current ttyrec, or null if there are no open ttyrecs.
     */
    public Ttyrec getCurrentTtyrec() {
        if (getCurrentSource() == null) return null;
        return getCurrentSource().getTtyrec();
    }

    // This method exists to avoid causing problems with missing fields
    // in early JDK versions.
    private Object safelyGetRenderingHint(String hintName) {
        try {
            return RenderingHints.class.getField(hintName).get(null);
        } catch(NoSuchFieldException | SecurityException |
                IllegalArgumentException | IllegalAccessException e) {
            return RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
        }
    }

    void setTerminalFont(String fontName) {
        replayTerminal.setFont(new Font(
                fontName,Font.PLAIN,11));
    }

    /**
     * Returns the font currently used by the terminal.
     * @return A Font that is used to display data in the terminal.
     */
    public Font getTerminalFont() {
        return replayTerminal.getFont();
    }

    /**
     * The main entry point for the Jettyplay application.
     * Parses and applies the effects of command-line arguments; if the
     * arguments did not request an immediate exit, also creates a new main
     * window for the Jettyplay application GUI and shows it.
     * @param args The command-line arguments to parse.
     */
    public static void main(String[] args) {
        // Look for help or version args, and reply and exit if one is given.
        boolean ddflag = false;
        for(String a : args) {
            if (ddflag) {ddflag = false; continue;}
            if(a.equals("-v") || a.equals("--version")) {
                System.err.println("This is jettyplay version "+
                        JettyAboutBox.versionInfo+".");
                System.err.println(JettyAboutBox.copyrightInfo);
                System.exit(0);
            }
            if(a.equals("-h") || a.equals("--help")) {
                System.err.println("filenames   Load the given file/files");
                System.err.println("-z 80x24    Force terminal size to 80x24 (likewise for other sizes)");
                System.err.println("-f 1200     Jump to frame 1200 upon loading (likewise for other frames)");
                System.err.println("-s 4        Set speed to 4x realtime (likewise for other speeds)");
                System.err.println("-l          Automatically fast-forward through periods of inactivity");
                System.err.println("--          Treat next arg as a filename even if it starts with -");
                System.err.println("-h          Show this help, then exit");
                System.err.println("-v          Show version and copyright information, then exit");
                System.exit(0);
            }
            if(a.equals("--")) ddflag = true;
        }
        // Set up the GUI.
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException |
                 IllegalAccessException | UnsupportedLookAndFeelException ex) {
            // if we can't set a system look and feel, just use the default...
        }
        // Set up networking, if we're allowed to.
        try {
            URL.setURLStreamHandlerFactory(new JettyURLStreamHandlerFactory());
        } catch (SecurityException e) {
            // oh well, we just can't use those protocols because the security
            // manager won't let us
            System.err.println(
                    "Nonstandard protocols disabled for security reasons.\n");
        }
        JettyFrame me = new JettyFrame();
        me.setDefaultCloseOperation(EXIT_ON_CLOSE);
        me.setSize(800, 600);
        me.setTitle("Jettyplay");
        me.setVisible(true);
        // Apply the effects of options
        ddflag = false;
        boolean speedflag = false;
        boolean sizeflag = false;
        boolean frameflag = false;
        String pendingSize = null;
        String pendingFrame = null;
        for (String a : args) {
            if (speedflag) {
                try {
                    me.speedSpinner.setValue(Double.valueOf(a));
                } catch (NumberFormatException ex) {
                    // ignore invalid input
                }
                speedflag = false;
                continue;
            }
            // if size or frame is being set this arg, turn on ddflag so the
            // arg isn't interpreted as anything else, and fall past the
            // filename check to the size/frame check
            if (sizeflag) {pendingSize = a; ddflag = true;}
            if (frameflag) {pendingFrame = a; ddflag = true;}
            if (a.equals("-l") && !ddflag) {
                me.autoskipButton.setSelected(true);
                me.autoskipMenuItem.setSelected(true);
                me.updateSidebar();
                continue;
            }
            if(a.equals("-s") && !ddflag) {speedflag = true; continue;}
            if(a.equals("-f") && !ddflag) {frameflag = true; continue;}
            if(a.equals("-z") && !ddflag) {sizeflag = true; continue;}
            if(a.equals("--") && !ddflag) {ddflag = true; continue;}            
            ddflag = false;
            if (!sizeflag && !frameflag) {
                // Looks like it's a filename...
                try {
                    URL u = new URL(a);
                    me.openSourceFromInputStreamable(new InputStreamableURLWrapper(u));
                } catch (MalformedURLException ex) {
                    File f = new File(a);
                    me.openSourceFromInputStreamable(new InputStreamableFileWrapper(f));
                }
            }
            // Check to see whether to apply forced size, or to go to a frame.
            sizeflag = false;
            frameflag = false;
            if (me.getCurrentSource() != null && pendingSize != null) {
                me.setForcedSizeFromString(pendingSize);
                pendingSize = null;
            }
            if (me.getCurrentSource() != null && pendingFrame != null) {
                try {
                    me.getCurrentSource().setWantedFrame(
                            Integer.valueOf(pendingFrame) - 1);
                    pendingFrame = null;
                } catch (NumberFormatException nfe) {
                    // do nothing
                }
            }
        }
    }
}
