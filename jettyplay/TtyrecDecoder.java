/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package jettyplay;

/**
 *
 * @author ais523
 */
public class TtyrecDecoder extends TtyrecWorker {

    private int analyzerSeq;
    private int rows;
    private int columns;
    private Ttyrec.Encoding encodingCreatedWith;

    /**
     * Creates a new ttyrec decoder.
     * @param source The TtyrecSource of the ttyrec to decode.
     * @param seq The sequence number of this worker.
     * @param rows The number of rows to decode for.
     * @param columns The number of columns to decode for.
     */
    public TtyrecDecoder(TtyrecSource source, int seq, int rows, int columns) {
        super(source, seq, "Ttyrec Decoder");
        this.analyzerSeq = source.getAnalyzerSequenceNumber();
        this.rows = rows;
        this.columns = columns;
        this.encodingCreatedWith = source.getTtyrec().getActualEncoding();
        if (source.debug)
            System.out.println("Decoder created! (workingFor="+
                workingFor+workingFor.hashCode()+
                ", this="+this+this.hashCode()+")");
    }
    /**
     * Creates a new ttyrec decoder based on this one, designed to redecode
     * everything from the start.
     * @param analyzerSeq The sequence number of the analyzer to redecode from.
     * @return The new decoder.
     */
    public TtyrecDecoder cloneWithAnalyzerSequence(int analyzerSeq) {
        return new TtyrecDecoder(workingFor, workingFor.getNextSequenceNumber(),
                24, 80);
    }

    private void backportOnFormatMismatch() {
        Ttyrec rec = workingFor.getTtyrec();
        if (this.encodingCreatedWith != rec.getActualEncoding()) {
            synchronized (this) {
                if (!this.isHalted) {
                    this.encodingCreatedWith = rec.getActualEncoding();
                    workingFor.newBackportWorkerOfType(this,
                            new TtyrecDecoder(workingFor,
                            workingFor.getNextSequenceNumber(),
                            rows, columns));
                }
            }
        }
    }

    /**
     * Decodes each frame of the ttyrec in turn.
     */
    @Override
    public void run() {
        TtyrecFrame lastFrame = null;
        Ttyrec rec = workingFor.getTtyrec();
        int afc = 0;
        setProgress(0);
        while (continueMainLoop()) {
            // We need to wait until a frame is available that was
            // generated by either the worker we're decoding for, or a
            // newer one.
            while (rec.getFrameCount() <= afc ||
                   rec.getFrameAtIndex(afc).getAnalyzerSeqNumber() < analyzerSeq) {
                backportOnFormatMismatch();
                synchronized (rec) {
                    try {
                        rec.wait();
                    } catch (InterruptedException ex) {
                        return;
                    }
                }
            }
            TtyrecFrame frame = rec.getFrameAtIndex(afc);
            if (frame.getDecoderSeqNumber() > sequenceNumber) {
                // We've been overtaken.
                subsume();
                return;
            }
            if (rec.getForcedHeight() != -1) {
                rows = rec.getForcedHeight();
                columns = rec.getForcedWidth();
            }
            frame.decodeFrame(rec.getActualEncoding(), rows, columns,
                    rec.getForcedHeight() != -1,
                    rec.containsAutoResizeRangeInformation(
                    analyzerSeq, sequenceNumber),
                    sequenceNumber);
            switch (frame.getTerminalState().getCharacterEncodingOverride()) {
                case Latin1:
                    rec.setNotUTF8();
                    rec.setNotIBM();
                    break;
                case UTF8:
                    rec.setNotLatin1();
                    rec.setNotIBM();
                    break;
            }
            backportOnFormatMismatch();
            if (frame.getTerminalState().isAutoResize()) {
                int c = frame.getTerminalState().getColumns();
                int r = frame.getTerminalState().getRows();
                if ((c > columns || r > rows) &&
                        rec.getForcedHeight() == -1) {
                    // arbitrary: 500x500 or more means something went wrong
                    // probably the recording was made on a terminal where
                    // curses can't be distinguished from non-curses
                    // so set to 80x24 nonresizing; maybe the user will add
                    // an override
                    if (c >= 500 || r >= 500) {
                        synchronized (this) {
                            if (!this.isHalted) {
                                int s = workingFor.getNextSequenceNumber();
                                rec.overrideContainsAutoResizeRangeInformation(s);
                                workingFor.newBackportWorkerOfType(this,
                                        new TtyrecDecoder(workingFor, s, 24, 80));
                            }
                            stopWorking(); // can't continue meaningfully
                        }
                    } else {
                        // We expand the state of this decoder, and start a
                        // backport decoder to fix the start of the encoding to
                        // the same size as the end.
                        columns = c;
                        rows = r;
                        synchronized (this) {
                            if (!this.isHalted) {
                                workingFor.newBackportWorkerOfType(this,
                                        new TtyrecDecoder(workingFor,
                                        workingFor.getNextSequenceNumber(), r, c));
                            }
                        }
                    }
                } else
                    afc++;
            } else
                afc++;
            setProgress(afc);
            lastFrame = frame;
            if (this.isInterrupted()) return;
        }
    }

    @Override
    protected void finalize() throws Throwable {
        if (workingFor.debug)
            System.out.println("Decoder finalized! (workingFor="+
                workingFor+workingFor.hashCode()+
                ", this="+this+this.hashCode()+")");
    }
}
